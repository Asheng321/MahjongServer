
/////////////////////////////////////////////////////////////////////////////
// 建 立 者: Vincent
//
// 建立日期: 2009/06/05
//
// S o 者: Vincent
//
// 最後修改:  
//
// f    明:
//  1. 13麻⑻ㄐ头治觯回鞲髋菩透鹘M合的符合0-14
 
/////////////////////////////////////////////////////////////////////////////
//
//    Copyright (C) 2009 Joymaster Corporation. All Rights Reserved.
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// @(#)profile.h
/////////////////////////////////////////////////////////////////////////////
//
//  ミ : Borton
//
// 廿撙榇: 2003/09/02
//
// 蝴 @ :
//
// 程岘拽: 2004/11/12
//
// 弧    : Profile wq郎.
//
/////////////////////////////////////////////////////////////////////////////
//
//    Copyright (C) 2003 Joymaster Corporation. All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////


package com.joymasterrocks.MJ13;
           



/////////////////////////////////////////////////////////////////////////////
// @(#)device.h
/////////////////////////////////////////////////////////////////////////////
//
//  ミ : Borton
//
// 廿撙榇: 2003/09/02
//
// 蝴 @ :
//
// 程岘拽: 2006/09/15
//
// 弧    : 杆mwq郎
//
// `Nㄆ兜:
//
//    1.DEVICE P EXTENSION 汗昊诩骗权盲－nAunU杆mぃ狡YiC
//    2.U杆m飓hWㄌ酚rダ抖潜痞CAHよKjM昧拽K狡C
//
/////////////////////////////////////////////////////////////////////////////
//
//    Copyright (C) 2003 - 2005 Joymaster Corporation. All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// 杆mwq
/////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////
// Acer
////////////////////////////////////////

////////////////////////////////////////

////////////////////////////////////////


////////////////////////////////////////
// Alcatel
////////////////////////////////////////

////////////////////////////////////////

////////////////////////////////////////


////////////////////////////////////////
// AMOI
////////////////////////////////////////

////////////////////////////////////////
// {MIDP 2.0},{CLDC 1.0} - M650

// {MIDP 2.0},{CLDC 1.0} - V600

// {MIDP 2.0},{CLDC 1.1} - A1

// {MIDP 2.0},{CLDC 1.0} - V600

////////////////////////////////////////


////////////////////////////////////////
// Asus
////////////////////////////////////////

////////////////////////////////////////
// {MIDP 1.0} - J101

// {MIDP 1.0} - J102

// {MIDP 1.0} - J103

// {MIDP 2.0} - V600

// {MIDP 2.0} - V80

// {MIDP 2.0} - M310 {240x320}

// {MIDP 2.0} - V70

// {MIDP 2.0} _Z802I 

// {MIDP 2.0} _J502 

////////////////////////////////////////
// BenQ-Siemens
////////////////////////////////////////

////////////////////////////////////////
// {CLDC 1.0}, {MIDP 1.0} - A500

// {MIDP 2.0} - CF61

// {CLDC 1.0}, {MIDP 2.0} - Hyperion

// {CLDC 1.0}, {MIDP 2.0} - M580

// {CLDC 1.0}, {MIDP 1.0} - A520(Fully Compatible with S660C/S670C) - for Bundle Only

// {CLDC 1.0}, {MIDP 2.0} - P30

// {CLDC 1.0}, {MIDP 2.0} - P50

// {CLDC 1.0}, {MIDP 2.0} - Pandora

// {CLDC 1.0}, {MIDP 2.0} - Pandora 2

// {CLDC 1.0}, {MIDP 1.0} - A520/S660C/S670C

// {CLDC 1.0}, {MIDP 2.0} - S700

// {CLDC 1.0}, {MIDP 1.0} - S830C

// {CLDC 1.0}, {MIDP 2.0} - S80

// {MIDP 2.0} - S81

// {CLDC 1.0}, {MIDP 2.0} - S82

// {CLDC 1.0}, {MIDP 2.0} - S88

// {CLDC 1.0}, {MIDP 2.0} - U700

// {CLDC 1.0}, {MIDP 2.0} - Z2

// {CLDC 1.1}, {MIDP 2.0} - SF71

// {CLDC 1.1}, {MIDP 2.0} - E81

// (CLDC 1.1), (MIDP 2.0) - T60



////////////////////////////////////////
// DBTEL
////////////////////////////////////////

////////////////////////////////////////
// {MIDP 1.0} - 8036C

// {MIDP 1.0} - M7



////////////////////////////////////////
// Dopod
////////////////////////////////////////

////////////////////////////////////////
// {MIDP 2.0},{CLDC 1.0} - 595

// {MIDP 1.0},{CLDC 1.0} - 9110

// {MIDP 2.0},{CLDC ?)-j嘲も诀 冈灿W妞８

////////////////////////////////////////
// HYBRID
////////////////////////////////////////

////////////////////////////////////////





////////////////////////////////////////
// LG
////////////////////////////////////////

////////////////////////////////////////





//{MIDP 2.0} F2500




//{MIDP 2.0} G282

//{MIDP 2.0} KG320

//{MIDP 2.0} KG920

//{MIDP 2.0} KG800



//{MIDP 2.0} KU310













////////////////////////////////////////
// MIDP 1.0
////////////////////////////////////////

////////////////////////////////////////



////////////////////////////////////////
// MIDP 2.0
////////////////////////////////////////

////////////////////////////////////////




////////////////////////////////////////
// Mitsubishi
////////////////////////////////////////

////////////////////////////////////////
// {CLDC 1.0}, {MIDP 2.0}, {240x275/240x240} - M750

// {DOJA 2.5}, {MIDP 2.0}, {240x270} - M790i, N600i, (NEC N400i, europe)



////////////////////////////////////////
// Motorola
////////////////////////////////////////

////////////////////////////////////////
// {CLDC 1.0}, {MIDP 2.0}, {128x128/128x143} - A732

// {CLDC 1.0}, {MIDP 2.0}, {128x128/128x143} - A732noext

// {CLDC 1.0}, {MIDP 2.0}, {240x275/240x240} - A760/A768

// {CLDC 1.0}, {MIDP 2.0}, {128x116/128x99} - C380/C650/V180/V220

// {CLDC 1.0}, {MIDP 2.0}, {176x205} - E398

// {CLDC 1.1}, {MIDP 2.0}, {240x320} - E680 (ㄏノS慝隽浃文脖饱\)

// {CLDC 1.0}, {MIDP 2.0}, {176x205} - E770

// {CLDC 1.1}, {MIDP 2.0}, {240x320} - E680

// {CLDC 1.0}, {MIDP 2.0}, {176x220} - RAZR V3

// {CLDC 1.0}, {MIDP 1.0}, {120x148/120x131} - T720/T720i/T720M

// {CLDC 1.0}, {MIDP 2.0}, {120x148/120x131} - T725

// {CLDC 1.0}, {MIDP 2.0}, {176x204/176x187} - V80/V300/V303/V400/V500/V501/V600/E398

// {CLDC 1.0}, {MIDP 2.0},

// {MIDP 2.0} V226

// {CLDC 1.0}, {MIDP 2.0}, {128x160/128x143} - V690

// {CLDC 1.0}, {MIDP 2.0}, {128x160/128x143} - V872/V878

// {CLDC 1.1}, {MIDP 2.0}, {240x320} - E1000

// {CLDC 1.1}, {MIDP 2.0}, {240x320} - E680 (ㄏノS慝隽浃文脖饱\)

// {CLDC 1.1}, {MIDP 2.0}, {240x300} - V1100

// {CLDC 1.1}, {MIDP 2.0}, {320x240} - E8

// {CLDC 1.1}, {MIDP 2.0}, {240x320} - V8

// {CLDC 1.1}, {MIDP 2.0}, {240x320} - E1000


////////////////////////////////////////
// NEC
////////////////////////////////////////

////////////////////////////////////////
// {MIDP 2.0} - N110

// {DOJA 2.5} - N600i

// {DOJA 1.5} - N630i, (N341i,jp)

// {DOJA 1.5} - N352i, N353i, N590i, N650i

// {DOJA 1.5} - N770i/N511i/N512i

// {MIDP 1.0} - N800/N810

// {MIDP 1.0} - N820/N830

// {MIDP 2.0} - N840

// {MIDP 2.0} - N840



////////////////////////////////////////
// Nokia
////////////////////////////////////////

////////////////////////////////////////
// Series 30


// Series 40 V1


// {CLDC 1.0}, {MIDP 1.0}, {SKTP 1.2} - X108 パspecぃì,G既ノnokia杭姚・浯


// Series 40 V2

// {CLDC 1.1}, {MIDP 2.0}

// {CLDC 1.1}, {MIDP 2.0}

// {CLDC 1.1}, {MIDP 2.0}

// {CLDC 1.1}, {MIDP 2.0}, {128x160/128x143}

// {CLDC 1.1}, {MIDP 2.0}, {208x220/208x208}




// Series 60 V1



// Series 60 V2





// Series 60 V3






// Series 60 V5

// Series 80


// Series 90



///////////////////////////////
// for N还膝,wq盎ǖ鬲
///////////////////////////////





////////////////////////////////////////
// OKWAP
////////////////////////////////////////

////////////////////////////////////////
// {MIDP 1.0} - S762




////////////////////////////////////////
// Panasonic
////////////////////////////////////////

////////////////////////////////////////



////////////////////////////////////////
// Philips
////////////////////////////////////////

////////////////////////////////////////



////////////////////////////////////////
// SAGEM
////////////////////////////////////////

////////////////////////////////////////
// {CLDC 1.0}, {MIDP 2} MY 401X

// {CLDC 1.0}, {MIDP 2} MY X-5

// {CLDC 1.0}, {MIDP 2} MY X-6

// {CLDC 1.0}, {MIDP 2} MY X-8

// {CLDC 1.0}, {MIDP 2} MY 501X




////////////////////////////////////////
// SAMSUNG
////////////////////////////////////////

////////////////////////////////////////
// {CLDC 1.1}, {MIDP 2.0} D608

////////////////////////////////////////
// {CLDC 1.0}, {MIDP 1.0}, {SKTP 1.2} - X789

// {CLDC 1.0}, {MIDP 1.0}, {SKTP 1.2} - X108
//#define DEVICE_SAMSUNG_X108       (EXTENSION_SAMSUNG + 0x0003)
////////////////////////////////////////
// {CLDC 1.1}, {MIDP 2.0} e258

////////////////////////////////////////
// {CLDC 1.1}, {MIDP 2.1} I8510






////////////////////////////////////////
// {CLDC 1.1}, {MIDP 2.0} D848//////////

////////////////////////////////////////
// {CLDC 1.1}, {MIDP 2.0} D528//////////

////////////////////////////////////////
// {CLDC 1.1}, {MIDP 2.0} Z238//////////

// {CLDC 1.1}, {MIDP 2.0} I718//////////


// {CLDC 1.1}, {MIDP 2.0} E378//////////

////////////////////////////////////////

////////////////////////////////////////
// SHARP
////////////////////////////////////////

////////////////////////////////////////
// {MIDP 1.0} - i98

// {MIDP 1.0} - GX21/GX31

// {MIDP 2.0} - GX-T15

// {MIDP 2.0} - GX-T25

// {MIDP 1.0} - GX21/GX31

// {MIDP 2.0} - GX-T33





////////////////////////////////////////
// SHARP_CJSP(淮SmarTone)
////////////////////////////////////////

////////////////////////////////////////
// {MIDP 1.0} - i98

// {MIDP 1.0} - GX21/GX31

// {MIDP 2.0} - GX-T15

// {MIDP 2.0} - GX-T25



////////////////////////////////////////
// SHARP_JSCL(らセVodafone)
////////////////////////////////////////

////////////////////////////////////////
// {MIDP 1.0} - i98

// {MIDP 1.0} - GX21/GX31

// {MIDP 2.0} - GX-T15

// {MIDP 2.0} - GX-T25

// {MIDP 2.0} - GX-T91




////////////////////////////////////////
// SHARP_NO_EXT(い地qH, 淮涞サLMノ API)
////////////////////////////////////////

////////////////////////////////////////
// {MIDP 1.0} - i98

// {MIDP 2.0} - GX-T15

// {MIDP 2.0} - GX-T25

// {MIDP 2.0} - GX-T71, GX-T91

// {MIDP 2.0} - WX-T92

// {MIDP 1.0} - gx21

// (MIDP 2.0) - GX-T82


////////////////////////////////////////
// SIEMENS
////////////////////////////////////////

////////////////////////////////////////



////////////////////////////////////////
// SKTT
////////////////////////////////////////

////////////////////////////////////////
// {CLDC 1.0}, {MIDP 1.0}, {SKTP 1.2} - AP1000






////////////////////////////////////////
// Sony Ericssion
////////////////////////////////////////

////////////////////////////////////////
// {CLDC 1.0}, {MIDP 1.0}, {128x128} - T610/T630

// {CLDC 1.1}, {MIDP 2.0}, {128x128/128x160} - K500

// {CLDC 1.0}, {DJOA 2.5}, {176x176} - K610im

// {CLDC 1.1}, {MIDP 2.0}, {176x220/176x181} - K700

// {CLDC 1.1}, {MIDP 2.0}, {240x320/240x220} - M600

// {CLDC 1.1}, {MIDP 2.0} - P990i

// {CLDC 1.1}, {MIDP 2.0} - S700


// {CLDC 1.1}, {MIDP 2.0} - W950

// {CLDC 1.1}, {MIDP 2.0} - S700

// {CLDC 1.1}, {MIDP 2.0}, {176x220/176x181} - K700

// {CLDC 1.1}, {MIDP 2.0}, {480x810/480x742} - XXL

// {CLDC 1.1}, {MIDP 2.0}, {176x220/176x176} - S302


////////////////////////////////////////
// WINII
////////////////////////////////////////

////////////////////////////////////////
// {CLDC 1.0}, {MIDP 2.0}, {176x204/176x184} - F868

// {CLDC 1.1}, {MIDP 2.0}, {240x320/240x296} - v825


//////////////////////////////////////////
//TOSHIBA
/////////////////////////////////////////

////////////////////////////////////////////
//{CLDC 1.0}, {MIDP 2.0}, {240x293/240x261} - TOSHIBA_803

//{CLDC 1.0}, {MIDP 2.0}, {176x179/176x220} - TOSHIBA_ts32

/////////////////////////////////////////////////////////////

//////////////////////////////////////////
//SANYO
/////////////////////////////////////////

////////////////////////////////////////////
//{CLDC 1.1}, {MIDP 2.0}, {240x260/240x260} - SANYO_S103

/////////////////////////////////////////////////////////////


////////////////////////////////////////
// DOJA 1.5
////////////////////////////////////////

////////////////////////////////////////

///////////////////////////////////////////////////////////////


////////////////////////////////////////
// PHS
////////////////////////////////////////

////////////////////////////////////////



////////////////////////////////////////
// DOJA 5.1
////////////////////////////////////////

////////////////////////////////////////

///////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////


////////////////////////////////////////
// HTC
////////////////////////////////////////

////////////////////////////////////////



///////////////////////////////////////////////////////////////

////////////////////////////////////////
// HUAWEI
////////////////////////////////////////

////////////////////////////////////////


//////////////////////////////////////////////
//LENOVO j嘲も诀
/////////////////////////////////////////////

////////////////////////////////////////


///////////////////////////////////////////////

////////////////////////////////////////


////////////////////////////////////////
// PHONE_TEST
////////////////////////////////////////

////////////////////////////////////////


////////////////////////////////////////
// KTouch
////////////////////////////////////////

////////////////////////////////////////


////////////////////////////////////////
// ZTE
////////////////////////////////////////

////////////////////////////////////////
// {CLDC 1.1}, {MIDP 2.0}, {176x220} - F188


/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////
// ANDROID
////////////////////////////////////////

////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////
// Pattern wq
/////////////////////////////////////////////////////////////////////////////








/////////////////////////////////////////////////////////////////////////////
// Font wq
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// Sound wq
/////////////////////////////////////////////////////////////////////////////





/////////////////////////////////////////////////////////////////////////////
// 戈方]弄 wq
/////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////
// Profile wq
/////////////////////////////////////////////////////////////////////////////



















  
  
  


/////////////////////////////////////////////////////////////////////////////
// LOCALE wq
/////////////////////////////////////////////////////////////////////////////

// ^y


// c砰いゅ


// c砰いゅ(淮)


// 虏砰いゅ


// wゅ


// kゅ


/////////////////////////////////////////////////////////////////////////////
// o姘 / q隔
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////
// xW伐P姘尸歆(www.joymaster.com.tw)
////////////////////////////////////////



// c砰いゅ, JAD H ASCII sX


// c砰いゅ, JAD H UTF-8 sX


// ^ゅ, JAD H ASCII sX


// 虏砰いゅ, JAD H UTF-8 sX


// c砰いゅ, JAD H ASCII sX


// c砰いゅ, JAD H ASCII sX, る怖]Mノ


////////////////////////////////////////
// xW
////////////////////////////////////////

////////////////////////////////////////
// い瓣
////////////////////////////////////////

// 计r辰(www.digifun.cn)


// 呼(www.163.com)

// ┰溜_CMCC

// ┰溜


// 淮







////////////////////////////////////////
// らセ
////////////////////////////////////////

// G-mode


// BANDAI


////////////////////////////////////////
// 醢
////////////////////////////////////////

// DEBUZ(www.debuz.com)


// GameSquare(www.gamesquare.com)


/////////////////////////////////////////////////////////////////////////////
// qH~
/////////////////////////////////////////////////////////////////////////////

// qノW


////////////////////////////////////////
// xW
////////////////////////////////////////

// ㄈび姘(栏é惠nノ)


// 环肚qH(www.fetnet.net)



// い地qH(www.cht.com.tw)


// xWj簸j(www.tcc.net.tw)


// MHqH(www.kgt.com.tw)


// FHqT(www.mobitai.net)


// 履_qH(www.vibo.com.tw)


// 伐P姘尸歆(Somuch)




////////////////////////////////////////
// い瓣
////////////////////////////////////////

// い瓣簿笆


// 淮







////////////////////////////////////////
// SNAP
////////////////////////////////////////




////////////////////////////////////////
// らセ
////////////////////////////////////////


////////////////////////////////////////
// 醢
////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////








  






/////////////////////////////////////////////////////////////////////////////


import java.io.*;
import java.util.*;
/////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////
































import android.app.Activity;
import android.content.res.Configuration;
import android.os.Bundle;
import android.view.*;

/////////////////////////////////////////////////////////////////////////////
import au.*;
import co.*;
import gm.*;




import ui.*;
import ut.*;
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//    Copyright (C) 2003 - 2005 Joymaster Corporation. All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// @(#)customize.h
/////////////////////////////////////////////////////////////////////////////
//
//  ミ : Borton
//
// 廿撙榇: 2003/09/02
//
// 蝴 @ :
//
// 程岘拽: 2004/11/05
//
// 弧    : TileFramework API \喋wq郎.
//
/////////////////////////////////////////////////////////////////////////////
//
//    Copyright (C) 2004 Joymaster Corporation. All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////
// 叫ㄌ沮惠DAwqUC才腹AH簿埃ゼㄏノ\啶 API {ΑXJ
//////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// 棵辊
////////////////////////////////////////////////////////////////





//pOIwq



  

 
//n龄t参酶s瓜
//#define DRAW_SOFTKEY_IMAGE














































































































////////////////////////////////////////////////////////////////
// 戈方O_笆A更J
////////////////////////////////////////////////////////////////





////////////////////////////////////////////////////////////////
// O_哀C戈方も诀: ㄏノt参r┪{Α勖辅莹N瓜郎戈方
////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////
// O_矗ㄑ_笆 ( 莫Gt氦＜ )
////////////////////////////////////////////////////////////////
 
    
 

////////////////////////////////////////////////////////////////
// 匡虫O_K瓜 ( 戈方ぃì憾Kゅr )
////////////////////////////////////////////////////////////////





//===========================================================================
//刚
//===========================================================================
//#define TRIAL_VERSION



//////////////////////////////////////////////////////////////////////////////
// Framework
//////////////////////////////////////////////////////////////////////////////
// ぃㄏノsΑ郝菠篇 API, ]t Menu, MenuListener,
// の虏て┆ Animation, TileSet 更Jㄧ计.


//////////////////////////////////////////////////////////////////////////////
// Animation
//////////////////////////////////////////////////////////////////////////////

// Animation ぃ惠o膀非I亥\


// Animation ぃㄏノ膀非I, 酶瓜嗓７|把σ膀非I, 巩丧iN膀非I簿暗ㄤLノ~(pK瓜旄m)


// Animation ぃ惠笆eO戈T\


//////////////////////////////////////////////////////////////////////////////
// Control & LWindow
//////////////////////////////////////////////////////////////////////////////

// Control EDIT じン程ji块Jrじ计ヘ




    
    

// Control / LWindow ぃ惠じン disable \


// Control / LWindow ぃ惠冀癍导/诞磨\
//#define CONTROL_NO_SOUND

// Sound 惠n刀q北睽\



// Control ぃ惠冀癜实e\


// Control ぃ惠笆ew\


// Control ぃ惠痹zw\



// Control / LWindow ぃ惠 CHOICE じン\


// Control / LWindow ぃ惠 TICKER じン\


// Control ぃ惠nh妞濡r]w/o\


// LWindow ぃ惠辈笆\


// LWindow ㄣΤ focus じン涵董爆O_惠n辈笆\


// LWindow ぃ惠I春闽d酶瓜\


// LWindow ぃ惠I春a瓜酶瓜\


// LWindow ぃ惠い_磅妤\


// Control ぃ惠 Listener \


// Control ぃ惠nh逼龆s北睽\(HWU龄北 focus 锣簿), p setColumnLayout ㄧ计


// Control / LWindow ぃ惠(逼婧])戈瞥s挡\, P STORE_NO_BIND @ノ郐P


// Control / LWindow ぃ惠ず丐弗螗\


//////////////////////////////////////////////////////////////////////////////
// Layer & LayerManager
//////////////////////////////////////////////////////////////////////////////

// Layer ぃ惠 getParent \


//////////////////////////////////////////////////////////////////////////////
// Level & GameCanvas
//////////////////////////////////////////////////////////////////////////////

//wqぃㄏノ GameCanvas  MIDP 2.0 も诀






// Level ぃ惠 timer \


// Level ぃ惠 keyRepeated \
//#define LEVEL_NO_KEY_REPEAT


















//#define LEVEL_NO_POINTER_PRESSED
//#define LEVEL_NO_POINTER_RELEASED








// Level ぃ惠 getDefaultFont \


// Level ぃ惠 getSmallFont \


// Level ぃ惠 getMediumFont \


// Level ぃ惠 getLargeFont \


// Level ぃ惠 hook 笆e\


// Level ぃ惠娴{Aq茎\: stateChanged()
//#define LEVEL_NO_STATE_NOTIFY

// Level drawText() ㄧ计ゲ斗暗ゅrち澄(w]挨０)


// Level ぃ惠 hook \


//////////////////////////////////////////////////////////////////////////////
// Sound
//////////////////////////////////////////////////////////////////////////////

// Sound ぃ惠I\






//////////////////////////////////////////////////////////////////////////////
// Tile & TileSet
//////////////////////////////////////////////////////////////////////////////

// Tile ぃ惠oO戈T\


// Tile ぃ惠B~妮┦ getProperty \


// Map ぃ惠 getProperty \


//////////////////////////////////////////////////////////////////////////////
// Store & Storeable
//////////////////////////////////////////////////////////////////////////////
// Storeable ぃ惠呼隔(逼婧])WU肚\


// Storeable ぃ惠(逼婧])逼钎\


// Store ぃ惠nL戳\
//#define STORE_NO_EXPIRE


////////////////////////////////////////////////////////////////
// Progress
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// O_陪ボ SoMuch Logo ( эパ C栏.property wq )
////////////////////////////////////////////////////////////////

//]w陪ボゑㄒ


/////////////////////////////////////////////////////////////////////////////
//
//    Copyright (C) 2004 Joymaster Corporation. All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//    Copyright (C) 2003 Joymaster Corporation. All Rights Reserved.
//
//////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//PaiAnalysis.java
/////////////////////////////////////////////////////////////////////////////

public class PaiAnalysis
{

    public final static int DaSiXi                  = 0;//大四喜
    public final static int DaSanYuan               = 1;//大三元
    public final static int LuYiShai                = 2;//G一色
    public final static int JiuLianBaoDeng          = 3;//九
    public final static int SiGang                  = 4;//四
    public final static int LianQiDui               = 5;//B七
    public final static int ShiSanYao               = 6;//十三么
    public final static int QingYaoJiu              = 7;//清么九
    public final static int XiaoSiXi                = 8;//小四喜
    public final static int XiaoSanYuan             = 9;//小三元
    public final static int ZiYiShai                = 10;//字一色
    public final static int SiAnKe                  = 11;//四暗刻
    public final static int YiShaiShuangLongHui     = 12;//一色p
    public final static int YiShaiSiTongShun        = 13;//一色四同
    public final static int YiShaiSiJieGao          = 14;//一色四高
    public final static int HunYaoJiu               = 15;//混么九
    public final static int YiShaiSiBuGao           = 16;//一色四步高
    public final static int SanGang                 = 17;//三
    public final static int QiDui                   = 18;//七
    public final static int QiXingBuKao             = 19;//七星不靠
    public final static int QuanShuangKe            = 20;//全p刻
    public final static int QingYiShai              = 21;//清一色
    public final static int YiShaiSanTongShun       = 22;//一色三同
    public final static int YiShaiSanJieGao         = 23;//一色三高
    public final static int QuanDai                 = 24;//全大
    public final static int QuanZhong               = 25;//全中
    public final static int QuanXiao                = 26;//全小
    public final static int QingLong                = 27;//清
    public final static int SanShaiShuangLongHui    = 28;//三色p
    public final static int YiShaiSanBuGao          = 29;//一色三步高
    public final static int QuanDaiWu               = 30;//全五
    public final static int SanTongKe               = 31;//三同刻
    public final static int SanAnKe                 = 32;//三暗刻
    public final static int QuanBuKao               = 33;//全不靠
    public final static int ZuHeLong                = 34;//M合
    public final static int DaiYuWu                 = 35;//大於五
    public final static int XiaoYuWu                = 36;//小於五
    public final static int SanFengKe               = 37;//三L刻
    public final static int HuaLong                 = 38;//花
    public final static int TuiBuDao                = 39;//推不倒
    public final static int SanShaiSanTongShun      = 40;//三色三同
    public final static int SanShaiSanJieGao        = 41;//三色三高
    public final static int WuFanHe                 = 42;//o番和
    public final static int MiaoShouHuiChun         = 43;//妙手回春
    public final static int HaiDiLaoYue             = 44;//海底圃
    public final static int GangShangKaiHua         = 45;//上_花
    public final static int QiangGangHe             = 46;//和
    public final static int PengPengHe              = 47;//碰碰和
    public final static int HunYiShai               = 48;//混一色
    public final static int SanShaiSanBuGao         = 49;//三色三步高
    public final static int WuMenQi                 = 50;//五TR
    public final static int QuanQiuRen              = 51;//全求人
    public final static int ShuangAnGang            = 52;//p暗
    public final static int ShuangJianKe            = 53;//p箭刻
    public final static int QuanDaiYao              = 54;//全么
    public final static int BuQiuRen                = 55;//不求人
    public final static int ShuangMingGang          = 56;//p明
    public final static int HeJueZhang              = 57;//和^
    public final static int JianKe                  = 58;//箭刻
    public final static int QuanFengKe              = 59;//圈L刻
    public final static int MenFengKe               = 60;//TL刻
    public final static int MenQianQing             = 61;//T前清
    public final static int PingHe                  = 62;//平和
    public final static int SiQuiYi                 = 63;//四w一
    public final static int ShuangTongKe            = 64;//p同刻
    public final static int ShuangAnKe              = 65;//p暗刻
    public final static int AnGang                  = 66;//暗
    public final static int DuanYao                 = 67;//嗝
    public final static int YiBanGao                = 68;//一般高
    public final static int XiXiangFeng             = 69;//喜相逢
    public final static int LianLu                  = 70;//B六
    public final static int LaoShaoFu               = 71;//老少副
    public final static int YaoJiuKe                = 72;//么九刻
    public final static int MingGang                = 73;//明
    public final static int QueYiMen                = 74;//缺一T
    public final static int WuZi                    = 75;//o字
    public final static int BianZhang               = 76;//
    public final static int KanZhang                = 77;//坎
    public final static int DanDiaoJiang            = 78;//吾
    public final static int ZiMo                    = 79;//自摸
    public final static int HuaPai                  = 80;//花牌
	
    public static int quanFeng                      = 0;//圈L0-3
    public static int menFeng                       = 0;//TL0-3
	
	public static int TEST_JU                       = 1;
	public static int TEST_HE                       = 0;
	
	public static int[] hu = new int[14];//IsHuPai 用的列，若胡牌，此列依3332形式排好，且不改chiPeng指之前的牌
	public static int[] pai = new int[14];//IsHuPai 用的列，要z查的原始列
	
	public final static int[] FanShu =   
	                        {     //各牌型番
	                            88,88,88,88,88,88,88,64,64,64,//0-9
								64,64,64,48,48,32,32,32,24,24,//10-19
								24,24,24,24,24,24,24,16,16,16,//20-29
								16,16,16,12,12,12,12,12, 8, 8,//30-39
								 8, 8, 8, 8, 8, 8, 8, 6, 6, 6,//40-49
								 6, 6, 8, 6, 4, 4, 4, 4, 2, 2,//50-59
								 2, 2, 2, 2, 2, 2, 2, 2, 1, 1,//60-69
								 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,//70-79
								 1,//80
	                        };
	public final static int[][] BuJi=
	                        {//各牌型不清危index=上方代，EX：55不求人不61T清79自摸，-1表示o
							    {SanFengKe,PengPengHe,QuanFengKe,MenFengKe},//0
								{JianKe,ShuangJianKe},
								{-1},
								{QingYiShai},
								{PengPengHe,DanDiaoJiang,SanGang,ShuangAnGang,ShuangMingGang,AnGang,MingGang},//牌相P番等不
								{QiDui,QingYiShai,PingHe},//5
								{WuMenQi,QuanDaiYao,DanDiaoJiang},
								{QuanDaiYao,PengPengHe,YaoJiuKe,ShuangTongKe,WuZi},
								{SanFengKe},
								{JianKe,ShuangJianKe},
							    {QuanDaiYao,PengPengHe},//10
								{PengPengHe},
								{QiDui,QingYiShai,PingHe,LaoShaoFu},
								{YiShaiSanTongShun,YiShaiSanJieGao,SiQuiYi,YiBanGao},
								{YiShaiSanTongShun,YiShaiSanJieGao,PengPengHe},
								{QuanDaiYao,PengPengHe,YaoJiuKe},//15
								{YiShaiSanBuGao,LianLu,LaoShaoFu},
								{ShuangAnGang,ShuangMingGang,AnGang,MingGang},//3牌以下相P番等不
								{DanDiaoJiang,QuanDaiYao},//新增不QuanDaiYao，因槟壳z查方式算到全么，所以要排除
								{WuMenQi,DanDiaoJiang,QuanDaiYao},//新增不QuanDaiYao，因槟壳z查方式算到全么，所以要排除
							    {PengPengHe,DuanYao},//20
								{-1},
								{YiShaiSanJieGao,YiBanGao},
								{YiShaiSanTongShun},
								{DaiYuWu,WuZi},
								{DuanYao},//25
								{XiaoYuWu,WuZi},
								{LaoShaoFu},
								{PingHe,XiXiangFeng,LaoShaoFu,WuZi},
								{-1},
							    {DuanYao},//30
								{-1},
								{-1},
								{WuMenQi,DanDiaoJiang,QuanDaiYao},//新增不QuanDaiYao，因槟壳z查方式算到全么，所以要排除
								{-1},
								{WuZi},//35
								{WuZi},
								{-1},
								{-1},
								{QueYiMen},
							    {-1},//40
								{-1},
								{-1},
								{ZiMo},
								{-1},
								{ZiMo},//45
								{HeJueZhang},
								{-1},
								{-1},
								{-1},
							    {-1},//50
								{DanDiaoJiang},
								{-1},
								{JianKe},
								{-1},
								{MenQianQing,ZiMo},//55
								{-1},
								{QiangGangHe},
								{-1},
								{-1},
							    {-1},//60
								{-1},
								{WuZi},
								{-1},
								{-1},
								{-1},//65
								{-1},
								{WuZi},
								{-1},
								{-1},
							    {-1},//70
								{-1},
								{-1},
								{-1},
								{-1},
								{-1},//75
								{-1},
								{-1},
								{-1},
								{-1},
								{-1},//80
							};
	
	public final static String[] wordx =
	                        {
							    "一f","二f","三f","四f","五f","六f","七f","八f","九f","空牌",//0-9
								"一筒","二筒","三筒","四筒","五筒","六筒","七筒","八筒","九筒","空牌",//10-19
								"一l","二l","三l","四l","五l","六l","七l","八l","九l","空牌",//20-29
								"|L","南L","西L","北L","t中","青l","白板","空牌","空牌","空牌",//30-39
								"春花","夏花","秋花","冬花","梅花","m花","竹花","菊花","空牌","空牌",//40-49
							};
	public final static String[] word =
	                        {
							    "1wan","2wan","3wan","4wan","5wan","6wan","7wan","8wan","9wan","spaceCard",//0-9
								"1tong","2tong","3tong","4tong","5tong","6tong","7tong","8tong","9tong","spaceCard",//10-19
								"1tiau","2tiau","3tiau","4tiau","5tiau","6tiau","7tiau","8tiau","9tiau","spaceCard",//20-29
								"EAST","SOUTH","WEST","NORTH","RED","GREEN","WHITE","spaceCard","spaceCard","spaceCard",//30-39
								"1flower","2flower","3flower","4flower","5flower","6flower","7flower","8flower","spaceCard","spaceCard",//40-49
							};
	public final static String[] Fan =
	                        {
							    "四L","大三元","G一色","九","四",//0-4
							    "B七","十三么","清么九","小四L","小三元",//5-9
							    "字一色","四暗刻","一色p","一色四同","一色四高",//10-14
							    "混么九","一色四步高","三","七","七星不靠",//15-19
							    "全p刻","清一色","一色三同","一色三高","全大",//20-24
							    "全中","全小","清","三色p","一色三步高",//25-29
							    "全五","三同刻","三暗刻","全不靠","M合",//30-34
							    "大於五","小於五","三L刻","花","推不倒",//35-39
							    "三色三同","三色三高","o番和","妙手回春","海底圃",//40-44
							    "上_花","和","碰碰和","混一色","三色三步高",//45-49
							    "五TR","全求人","p暗","p箭刻","全么",//50-54
							    "不求人","p明","和^","箭刻","圈L刻",//55-59
							    "TL刻","T前清","平和","四w一","p同刻",//60-64
							    "p暗刻","暗","嗝","一般高","喜相逢",//65-69
							    "B六","老少副","么九刻","明","缺一T",//70-74
							    "o字","","坎","吾","自摸",//75-79
							    "花牌",//80
							};
							
	public final static String[] FanE =
	                        {
							    "DaSiXi","DaSanYuan","LuYiShai","JiuLianBaoDeng","SiGang",//0-4
							    "LianQiDui","ShiSanYao","QingYaoJiu","XiaoSiXi","XiaoSanYuan",//5-9
							    "ZiYiShai","SiAnKe","YiShaiShuangLongHui","YiShaiSiTongShun","YiShaiSiJieGao",//10-14
							    "HunYaoJiu","YiShaiSiBuGao","SanGang","QiDui","QiXingBuKao",//15-19
							    "QuanShuangKe","QingYiShai","YiShaiSanTongShun","YiShaiSanJieGao","QuanDai",//20-24
							    "QuanZhong","QuanXiao","QingLong","SanShaiShuangLongHui","YiShaiSanBuGao",//25-29
							    "QuanDaiWu","SanTongKe","SanAnKe","QuanBuKao","ZuHeLong",//30-34
							    "DaiYuWu","XiaoYuWu","SanFengKe","HuaLong","TuiBuDao",//35-39
							    "SanShaiSanTongShun","SanShaiSanJieGao","WuFanHe","MiaoShouHuiChun","HaiDiLaoYue",//40-44
							    "GangShangKaiHua","QiangGangHe","PengPengHe","HunYiShai","SanShaiSanBuGao",//45-49
							    "WuMenQi","QuanQiuRen","ShuangAnGang","ShuangJianKe","QuanDaiYao",//50-54
							    "BuQiuRen","ShuangMingGang","HeJueZhang","JianKe","QuanFengKe",//55-59
							    "MenFengKe","MenQianQing","PingHe","SiQuiYi","ShuangTongKe",//60-64
							    "ShuangAnKe","AnGang","DuanYao","YiBanGao","XiXiangFeng",//65-69
							    "LianLu","LaoShaoFu","YaoJiuKe","MingGang","QueYiMen",//70-74
							    "WuZi","BianZhang","KanZhang","DanDiaoJiang","ZiMo",//75-79
							    "HuaPai",//80
							};
							
	public static int[] checkOnece_14 = {//有符合档14牌型，需依y易度{整序，蔚姆徘懊
										 //混一色,全求人,碰碰和,七,清一色,三色p,全不靠,大於五,小於五,混么九,推不倒,G一色,十三么,字一色,一色p,
										   48,51,47,18,21,28,33,35,36,15,39,2,6,10,12,
										};
	public static int[] checkOnece_9 =  {//有符合档9牌型，需依y易度{整序，蔚姆徘懊
										 //三色三步高,三色三同,花,清,三色三高,三L刻,一色三步高,一色三同,一色三高
										   49,40,38,27,41,37,29,22,23,
										};
	
	public static int[] checkOften =    {//1或0 的牌型，每次M牌rz查
										 //五TR,箭刻,圈L刻,TL刻,T前清,四w一,p同刻,p暗刻,暗,嗝,一般高,喜相逢,B六,老少副,么九刻,明,缺一T,o字
										   50,58,59,60,61,63,64,65,66,67,68,69,70,71,72,73,74,75,
										};
										
	public static int[] checkOftenS =    {//可能}荡嬖诘呐菩停存在rz查有
										 //四w一,一般高,喜相逢,B六,老少副,么九刻,
										   63,68,69,70,71,72,
										};
										
	//有前置的牌型，一_始不用z查，等前置存在再z查
	//大四喜,大三元,四,B七,清么九,小四喜,小三元,四暗刻,一色四同,一色四高,一色四步高,三,七星不靠,全p刻,全大,全中,全小,三同刻,三暗刻,p暗,p箭刻,p明,九,
	//0,1,4,5,7,8,9,11,13,14,16,17,19,20,24,25,26,31,32,52,53,56,3,
										
	public static int[][] checkLater =  {//有前置的牌型，一_始不用z查，等前置[x][0]存在再z查
										   {37, 8, 0},//三L刻,小四喜,大四喜,
										   {58,53, 9, 1},//箭刻,p箭刻,小三元,大三元,
										   {73,56,17, 4},//明,p明,三,四,
										   {66,52,17, 4},//,暗,p暗,三,四,
										   {65,32,11},//p暗刻,三暗刻,四暗刻,
										   {64,31},//p同刻,三同刻,
										   {18, 5},//七,B七,
										   {15, 7},//混么九,清么九,
										   {22,13},//一色三同,一色四同,
										   {23,14},//一色三高,一色四高,
										   {29,16},//一色三步高,一色四步高,
										   {33,19},//全不靠,七星不靠,
										   {47,20},//碰碰和,全p刻,
										   {35,24},//大於五,全大,
										   {30,25},//全五,全中,
										   {36,26},//小於五,全小,
										   {21, 3},//清一色,九,
										};
										
	public static int[] checkIfHu =     {//胡牌後再z查的牌型，主e中呼叫，此渭榱吮容^
									     //妙手回春,海底圃,上_花,和,全么,不求人,和^,平和,,坎,吾,自摸.全五,//o番和：最後z查
										   43,44,45,46,54,55,57,62,76,77,78,79,30,//42,
										};
										
	public static int[] specialType =   {//非3332的特殊牌型
	                                     //B七,十三么,七,七星不靠,全不靠,M合
										   5,6,18,19,33,34,
										};

	public static String intToWord( int pai )
	{
	    String str = "牌序e`："+pai;
		if( pai==99 ) str = "o牌";
		if( pai==-10 ) str = "明";
		if( pai==-11 ) str = "暗";
		if( pai==-1 ) str = "此牌已被消除";
	    if( pai>49 || pai<0 ) return str;
		else
	    return word[pai];
	}
	
	public static void initWind()//初始化L位Y
	{
	    quanFeng = 0;
		menFeng = 0;
	}
	
	
	/**回髟牌列是否有不是<f筒l字>的牌
 	*@param pai 要z查的牌列
 	*@return 是否存在
 	*/
	private static boolean checkExPai( int[] pai )
	{
	    for( int i=0; i<pai.length; i++ )
		    {
			    if( pai[i] > 36 ) return true;
			}
			
		return false;
	}
	
	/**回髟牌列在牌型之最高符合
	*@param player for MemFengKe
 	*@param info[][] 玩家手牌Y三S列，EX：[ 4 = f筒l字 ] [ 4 = 表+表+稳北+缺表 ] [1-12各Y料]
 	*@param source[] 要z查的牌列
 	*@param chiPeng 吃碰指
 	*@param target 要z查的目伺菩停EX：PaiAnalysis.YiShaiSanBuGao(  一色三步高 )
 	*@param IsHu 是否是胡牌後的z查，若是，部分z查如碰碰和，化S多
 	*@return num[] 0.最高符合(上限14)、1-14U牌、15-28：缺的牌。U牌指此牌型此符合度的M合下，]用到的牌；缺牌指此牌型此符合度的M合下，能增加符合度的牌。
 	*/
	public static int[] checkType( int player, int info_x[][], int[] source_x, int chiPeng, int target, boolean IsHu )//f0-8,  筒10-18,  l20-28 ,  |南西北中l白30-36
	{
	    int[][] info = new int[4][11];
		    for( int j=0; j<info_x.length; j++ )
				{
					System.arraycopy(info_x[j], 0, info[j], 0, info_x[j].length);
				}
					
	    int[] source = new int[14];
	    System.arraycopy(source_x, 0, source, 0, source_x.length);
		int last = source[13];
	    liPai( source, chiPeng, source.length-1 );
		
	    int[] num = {
		              0,
		             -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
					 -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
					};//0：符合怠1-14：U牌、15-28：缺的牌
		int x = 1;//U牌列位置指起始
		int y = 15;//缺牌列位置指起始
		
		try{
	    switch( target )
            {
				case DaSiXi://0.大四喜：前置37.三L刻可胡，成立1，不成立0。
				{
				    int feng = 0;
				    for( int i=0; i<=9; i+=3 )
					    {
						    if( source[i] == source[i+2] && source[i] >= 30 && source[i] <= 33 )//L刻
							    {
								    feng++;
								}
						}
					if( feng==4 )
					    {
						    num[0] = 1;
						}
					break;
				}
				
				case DaSanYuan://1.大三元：前置53.p箭刻可胡，成立1，不成立0。排除7
				{
				    int dsy = 0;
				    for( int i=0; i<hu.length/3; i++ )
					    {
						    if( hu[i*3]>=34 && hu[i*3]<=36 && hu[i*3]==hu[i*3+2] )//中l白刻子
							    {
								    dsy++;
								}
						}
					if( dsy==3 )
					    {
						    num[0] = 1;
						}
					break;
				}
				
				case LuYiShai://2.G一色：23468l或l字M成，o缺牌
				{
				    for( int i=0; i<source.length; i++ )
					    {
						    int s = source[i];
							if( s == -10 || s == -11 ) s = source[i+1];//牌苏IDQ
						    if( s==21 || s==22 || s==23 || s==25 || s==27 || s==35 )
							    {
									num[0]++;
								}
								else
								{
								    num[x] = s;//入U牌
									x++;
								}
							num[15]=21;
							num[16]=22;
							num[17]=23;
							num[18]=25;
							num[19]=27;
							num[20]=35;
						}
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("G一色符合:"+num[0]);
					break;
				}
				
				case JiuLianBaoDeng://3.九簦郝九洞才算，21.清一色成立才z查
				{
				    if( chiPeng > 0 ) break;//不可吃碰
					/*if( source[0]%10==0 && source[0]%10==0 && source[0]%10==0 //111
					 && source[0]%10==1 && source[0]%10==2 && source[0]%10==3 //234
					 && source[0]%10==4 && source[0]%10==5 && source[0]%10==6 //567
					 && source[0]%10==7 && source[0]%10==8 && source[0]%10==8 && source[0]%10==8 )//8999
					    {
						    num[0] = 1;System.out.println("num[0]="+num[0]);
						}
						else
						{
						   for(int i=0; i<14; i++)
						       System.out.println(word[source[i]]);
						}*/
					int suit = source[0]/10;
					if( info[suit][1]>2 && info[suit][2]>0 && info[suit][3]>0 //19.至少3, 2-8至少各1，LGame 要z查：若是1.123.456.789.999 + 1 OR pai[13]=2-8  =>>不成立，因椴皇锹9洞
					 && info[suit][4]>0 && info[suit][5]>0 && info[suit][6]>0
					 && info[suit][7]>0 && info[suit][8]>0 && info[suit][9]>2 )
					    {
						    num[0] = 1;
						}
				    /*int type = 0;//z查目前<f筒l>何者^多，//0-8 => 1-9f筒l
				    if( info[0][0] < info[1][0] ) type = 1;//f筒何者多?
					if( info[type][0] < info[2][0] ) type = 2;//<f筒>^多者c<l>，何者多?
					
					if( info[type][0] > 0 ) // 此花色至少要有一，算多的U牌及符合的盗
					    {
							if( info[type][1]==0 )
								{
								    num[y] = type*10 + (1-1);//]有，入缺牌
									y++;
								}
							    else if( info[type][1]>0 && info[type][1]<4 ) 
							    {
							        num[0] = num[0] + info[type][1];//1有1-3
								}
							    else if( info[type][1]==4 ) 
								{
								    num[0] = num[0] + 3;//1有4
									num[x] = type*10 + (1-1);//第四入U牌
									x++;
								}
								
						    for( int i=2; i<9; i++ )//2-8只要一
							    {
								    if( info[type][i]==0 )
									    {
										    num[y] = type*10 + (i-1);//]有，入缺牌
									        y++;
										}
								        else if( info[type][i]==1 ) 
									    {
										    num[0]++;//符合导1
										}
									    else if( info[type][i]>1 )//2.3.4
									    {
										    num[0]++;
										    for( int j=2; j<=info[type][i]; j++ )
											    {
												    num[x] = type*10 + (i-1);//第2以上入U牌
									                x++;
												}
										}
								}
							
							if( info[type][9]==0 )
								{
								    num[y] = type*10 + (9-1);//]有，入缺牌
									y++;
								}	
								else if( info[type][9]>0 && info[type][9]<4 ) 
							    {
								    num[0] = num[0] + info[type][9];//9有1-3
								}
								else if( info[type][9]==4 )
								{
								    num[0] = num[0] + 3;//9有4
									num[x] = type*10 + (9-1);//第四入U牌
									x++;
								}
						}
					
					for( int i=0; i<14; i++ )//找目嘶ㄉ以外的U牌
					    {
						    if( source[i] != 99 && source[i] / 10 != type )//不是目嘶ㄉ、不是空牌，直接U牌
							    {
								    num[x] = source[i];//入U牌
									x++;
								}
						}
					if( last/10==type && ( last%10==0 || last%10==8 ) ) num[0]++;//最後一是1或9
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("九舴合"+num[0]);*/
			        break;
				}
				
				case SiGang://4.四：前置17.三，成立1，不成立0。
				{
				    if( chiPeng==0 ) 
					    {
						    break;
						}
					    else
						{
				            for( int i=0; i<chiPeng/3; i++ )
					            {
						            if( source[i*3+1]==-10 || source[i*3+1]==-11 )//明暗
									    {
										    num[0]++;
										}
						        }
						}
					if( num[0] > 3 ) num[0] = 1;
					    else num[0] = 0;
					break;
				}
				
				case LianQiDui://5.B七Γ撼闪1，不成立0，18.七z查完，看是否檫Bm
				{
				    //num[0] = 1;
					liPai( source, 0, 13);
				    if( source[12]==source[10]+1 && 
					    source[10]==source[8]+1 && 
						source[8]==source[6]+1 && 
						source[6]==source[4]+1 && 
						source[4]==source[2]+1 && 
						source[2]==source[0]+1 )
					    {
							num[0] = 1;
						}
					break;
				}
				
                case ShiSanYao://6.十三么：十三洞才算
				{
				    if( chiPeng > 0 ) break;//不可吃碰
					for( int i=0; i<3; i++ )//z查f筒l
					    {
						    int xuShuo = 1;
						    for( int j=0; j<2; j++ )//z查序一九
							    {
								    if( j==0 ) xuShuo = 1;
									else xuShuo = 9;
									
						            if( info[i][xuShuo] == 0 )
							            {
								            num[y] = i*10 + (xuShuo-1);//]有，入缺牌
									        y++;
								        }
								        else if( info[i][xuShuo] == 1 )
								        {
								            num[0]++;//符合导1
								        }
								        else if( info[i][xuShuo] > 1 )
								        {
								            num[0]++;
									        for( int k=2; k<=info[i][xuShuo]; k++ )
									            {
										            num[x] = i*10 + (xuShuo-1);//第2以上入U牌
									                x++;
										        }
								        }
								}
							for( int j=2; j<=8; j++ )//z查序2-8
							    {
								    if( info[i][j] > 0 )
									    {
										    num[x] = i*10 + (j-1);//入U牌
									        x++;
										}
								}
						}
						
					for( int i=1; i<=7; i++ )//z查字30-36
					    {
						    if( info[3][i] == 0 )
							    {
								    num[y] = 3*10 + (i-1);//]有，入缺牌
									y++;
								}
								else if( info[3][i] == 1 )
								{
								    num[0]++;//符合导1
								}
								else if( info[3][i] > 1 )
								{
								    num[0]++;
									for( int k=2; k<=info[3][i]; k++ )
									    {
									        num[x] = 3*10 + (i-1);//第2以上入U牌
									        x++;
									    }
								}
						}
					if( num[0]==13 )//13具Rr
					    {
						    if( last/10<3 && (last%10==0||last%10==8) )//f筒l之19
							    {
								    num[0]++;
								}
								else if( last/10==3 && last%10<=6 )//字
								{
								    num[0]++;
								}
						}
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("十三么符合:"+num[0]);
			        break;
				}
				
				case QingYaoJiu://7.清么九：15.混么九成立後，z查是否有字，成立1，不成立0。
				{
				    int qyj = 1;
				    for( int i=0; i<source.length; i++ )
					    {
						    if( source[i] >= 30 ) 
							    {
								    qyj = 0;
									break;
								}
						}
						
					num[0] = qyj;
					break;
				}
				
				case XiaoSiXi://8.小四喜：前置37.三L刻可胡，成立1，不成立0。
				{
				    /*if( hu[12]>= 30 && hu[12] <= 33 )
					    {
						    num[0] = 1;
						}*/
					int feng = 0;
				    for( int i=0; i<=9; i+=3 )
					    {
						    if( hu[i] == hu[i+2] && hu[i] >= 30 && hu[i] <= 33 )//L刻
							    {
								    feng++;
								}
						}
					if( feng==3 && hu[12]>= 30 && hu[12] <= 33 )
					    {
						    num[0] = 1;
						}
					break;
				}
				
				case XiaoSanYuan://9.小三元：前置53.p箭刻可胡，成立1，不成立0。排除7
				{
				    /*if( hu[12]>= 34 && hu[12] <= 36 )
					    {
						    num[0] = 1;
						}*/
					int dsy = 0;
				    for( int i=0; i<hu.length/3; i++ )
					    {
						    if( hu[i*3]>=34 && hu[i*3]<=36 && hu[i*3]==hu[i*3+2] )//中l白刻子
							    {
								    dsy++;
								}
						}
					if( dsy==2 && hu[12]>= 34 && hu[12] <= 36 )
					    {
						    num[0] = 1;
						}
					break;
				}
				
				case ZiYiShai://10.字一色，回髦0-14
				{
				    int zi = 0;
				    for( int i=0; i<source.length; i++ )
					    {
						    if( source[i] == -10 || source[i] == -11 )//
							    {
								    source[i] = source[i+1];//牌中g的牌DQ苏I
								}
						    if( source[i]/10==3 )
							    {
								    zi++;
								}
								else
								{
						    	    num[x] = source[i];//入U牌
						       	    x++;
								}
						}
						
					for( int i=30; i<=36; i++ )
					    {
						    num[y] = i;//入缺牌
						    y++;
						}
						
					num[0] = zi;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("字一色符合:"+num[0]);
					break;
				}
				
				case SiAnKe://11.四暗刻，成立1，不成立0。
				{
				    int sak = 0;
					int sak2 = 0;
					int sak3 = 0;
				    if( chiPeng > 0 )//z查暗
					    {
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3+1] == -11 )//是暗
								    {
									    sak++;
									}
						    }
						}
					
					for( int i=chiPeng/3; i<hu.length/3; i++ )
					    {
						    if( hu[i*3]==hu[i*3+2] ) sak2++;
						}
					
					for( int i=0; i<=3; i++ )//四花色
					    {
						    for( int j=1; j<=9; j++ )
							    if( info[i][j]>=3 )//111222333=>123123123，所以要z查手牌
							        {
								        sak3++;
								    }
						}
					if( sak2 > sak3 ) sak = sak + sak2;
					    else sak = sak + sak3;
					if( sak >= 4 ) num[0] = 1;
						
					break;
				}
				
				case YiShaiShuangLongHui://12.一色p，回髦0-14
				{
				    int chiCate = -1;//已吃的花色
					int[] shun = {0,0};//123.789已吃的盗
				    boolean fail = false;
				    if( chiPeng > 0 )
					    {
						    for( int i=0; i<chiPeng/3; i++ )
					        {
						        if( source[i*3] == source[i*3+2] )//有碰
								    {
									    fail = true;
										break;
									}
									else//有吃，若o序46，且橥一色，把Y料塞回P表
								    {
									    for( int j=0; j<3; j++ )//z查吃M有o序46，有t中
										    {
										        if( source[i*3+j]%10==3 || source[i*3+j]%10==5 )
												    {
													    fail = true;
														break;
													}
											}
											
										if( !fail )//第二M以上的吃M，z查c前面吃M是否橥花色，不是t中 => 吃2M不同t花色o法成立
										    {
											    if( i==0 ) chiCate = source[i*3]/10;//若只吃ㄧM，t只z查此花色
												else if( i>0 )//有2M吃，於下方z查花色是否相同
												if( source[i*3]/10 != source[i*3-3]/10 )//花色不同
												    {
													    fail = true;
														break;
													}
													else//花色相同
													{
													    chiCate = source[i*3]/10;//o已吃的是哪N花色
													}
											}
											
										if( fail ) 
										    {
											    break;
											}
									}
						    }
							if( fail ) break;
							//至此皆橥花色的吃且123、789，o的^
							for( int i=0; i<chiPeng/3; i++ )
					            {
								    int head = source[i*3];
									if( source[i*3] > source[i*3+1] ) head = source[i*3+1];
									if( head > source[i*3+2] ) head = source[i*3+2];
									if( head%10==0 ) shun[0]++;
									else if( head%10==6 ) shun[1]++;
							    }
						}
						
					if( fail ) break;
					
					if( chiCate == -1 )//o已吃的花色，找1235789最多的花色
						{
						    int mx = 0;
							int tar = 0;
							for( int m=0; m<=2; m++ )
							    {
								    int mx_tmp = info[m][0] - info[m][4] - info[m][6];
									if( mx_tmp > mx ) 
									    {
										    tar = m;
											mx = mx_tmp;
										}
								}
							chiCate = tar;
						}
						
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(">>>>>>>>>>"+Fan[12]+"目嘶ㄉ:"+chiCate);
					
								
						    int[] temp = {
                      					   0,
		                                  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
					                      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
							  		     };
							int temp_x = 1;
							int temp_y = 15;
							//5的盗
							if( info[chiCate][5] < 2 )//缺5
							    {
								    num[0] = num[0] + info[chiCate][5];
									for( int j=2; j>2-info[chiCate][5]; j-- )
									    {
								    	    temp[temp_y] = chiCate*10+4;
										    temp_y++;
										}
								}
								else if( info[chiCate][5] == 2 )
								{
									num[0] = num[0] + 2;
								}
								else if( info[chiCate][5] > 2 )//多5
								{
									num[0] = num[0] + 2;
									for( int j=0; j<info[chiCate][5]-2; j++ )
									    {
								    	    temp[temp_x] = chiCate*10+4;
										    temp_x++;
										}
								}
							
						    if( shun[0]<2 )//123最多2M，未M2Mt找剩下的
							    {
								    if( shun[0]==0 )
									    {
										    if( info[chiCate][1]>=2 ) num[0] = num[0] + 2; else num[0] = num[0] + info[chiCate][1];
											if( info[chiCate][2]>=2 ) num[0] = num[0] + 2; else num[0] = num[0] + info[chiCate][2];
											if( info[chiCate][3]>=2 ) num[0] = num[0] + 2; else num[0] = num[0] + info[chiCate][3];
											
										}
										else if( shun[0]==1 )
										{
										    if( info[chiCate][1]>0 ) num[0] = num[0] + 1;
											if( info[chiCate][2]>0 ) num[0] = num[0] + 1;
											if( info[chiCate][3]>0 ) num[0] = num[0] + 1;
										}
										    
								}
								
						    if( shun[1]<2 )//789最多2M，未M2Mt找剩下的
							    {
								    if( shun[1]==0 )
									    {
										    if( info[chiCate][7]>=2 ) num[0] = num[0] + 2; else num[0] = num[0] + info[chiCate][7];
											if( info[chiCate][8]>=2 ) num[0] = num[0] + 2; else num[0] = num[0] + info[chiCate][8];
											if( info[chiCate][9]>=2 ) num[0] = num[0] + 2; else num[0] = num[0] + info[chiCate][9];
										}
										else if( shun[1]==1 )
										{
										    if( info[chiCate][7]>0 ) num[0] = num[0] + 1;
											if( info[chiCate][8]>0 ) num[0] = num[0] + 1;
											if( info[chiCate][9]>0 ) num[0] = num[0] + 1;
										}
										    
								}
								
							num[0] = num[0] + shun[0]*3 +shun[1]*3;
							
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(Fan[12]+"符合:"+num[0]);
					break;
				}
				
				case YiShaiSiTongShun://13.一色四同，22一色三同成立之後才z查
				{
				    if( chiPeng > 0 )
					    {
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] == source[i*3+2] )//有碰
								    {
									    break;
									}
									else//有吃，把Y料塞回P表
								    {
									    for( int j=0; j<3; j++ )
										    {
											    int a = source[i*3+j]/10;
												int b = source[i*3+j]%10+1;
												info[a][b] = info[a][b] + 1;
											}
									}
						    }
						}
				    for( int i=0; i<=2; i++ )//f筒l
					    {
						    for( int j=1; j<=6; j++ )//1234 ~ 6789
							    {
								    if( info[i][j]==4 && info[i][j+1]==4 && info[i][j+2]==4 )
									    {
										    num[0] = 1;
										}
								}
						}
						
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("一色四同："+IsExist(num[0]) );
					
					break;
				}
				
				case YiShaiSiJieGao://14.一色四高，23一色三高成立之後才z查
				{
				    if( chiPeng > 0 )
					    {
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] != source[i*3+2] )//有吃
								    {
									    break;
									}
									else//有碰，把Y料塞回P表
								    {
										int a = source[i*3]/10;
										int b = source[i*3]%10+1;
										info[a][b] = info[a][b] + 3;//也算3
									}
						    }
						}
				    for( int i=0; i<=2; i++ )//f筒l
					    {
						    for( int j=1; j<=6; j++ )//1234 ~ 6789
							    {
								    if( info[i][j]>2 && info[i][j+1]>2 && info[i][j+2]>2 && info[i][j+3]>2 )
									    {
										    num[0] = 1;
										}
								}
						}
						
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("一色四高："+IsExist(num[0]) );
					
					break;
				}
				
				case HunYaoJiu://15.混么九，1+9+字的刻子，未成刻子t要2才算入符合
				{
				    boolean IsYaoJiuExist = false;
					if( chiPeng > 0 )
					    {
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] != source[i*3+2] )//有吃
								    {
									    break;
									}
									else//有明刻
									{
									    if( source[i*3]%10 != 0 && source[i*3]%10 != 8 && source[i*3]/10 < 3 )//不是1.9.字
										    {
											    break;
											}
											else//是1.9.字
											{
											    num[0] = num[0] + 3;
											}
									}
						    }
						}
					
					for( int i=0; i<=2; i++ )//序悼
					    {
						    if( info[i][1] > 0 )
							    {
								    IsYaoJiuExist = true;
									num[0] = num[0] + info[i][1];
									if( info[i][1]==4 )  num[0]--;//4只能算3，所以扣一
								}
						    if( info[i][9] > 0 )
							    {
								    IsYaoJiuExist = true;
								    num[0] = num[0] + info[i][9];
									if( info[i][9]==4 )  num[0]--;
								}
						}
					
					for( int i=1; i<=7; i++ )//字刻
					    {
						    if( info[3][i] == 2 )
							    {
								    num[0] = num[0] + 2;
								}
								else if( info[3][i] > 2 )
								    {
									    num[0] = num[0] + 3;
									}
						}
						
					if( !IsYaoJiuExist )//]有序1.9不成立
					    {
						    num[0] = 0;
						}
					for( int i=0; i<source.length; i++ )//U牌
					    {
						    if( source[i]/10 < 3 && source[i]%10 != 0 && source[i]%10 != 8 )//f筒l非19
							    {
								    num[x] = source[i];
									x++;
								}
						}
					
					num[y] = 0; y++;
					num[y] = 8; y++;
					num[y] = 10; y++;
					num[y] = 18; y++;
					num[y] = 20; y++;
					num[y] = 28; y++;
					for( int i=30; i<=36; i++ )//入缺牌
					    {
						    num[y] = i;
						    y++;
						}
					break;
				}
				
				case YiShaiSiBuGao://16.一色四步高
				{
				    if( chiPeng > 0 )
					    {
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] == source[i*3+2] )//有碰
								    {
									    break;
									}
									else//有吃，把Y料塞回P表
								    {
										for( int j=0; j<3; j++ )
										    {
											    int a = source[i*3+j]/10;
												int b = source[i*3+j]%10+1;
												info[a][b] = info[a][b] + 1;
											}
									}
						    }
						}
					for( int i=0; i<=2; i++ )
					    for( int j=1; j<=4; j++ )//123 + 234 + 345 + 456...
					        {
						        if( info[i][j]==1 && info[i][j+1]==2 && info[i][j+2]==3 && info[i][j+3]==3 && info[i][j+4]==2 && info[i][j+5]==1 )
								    num[0] = 1;
						    }
					for( int i=0; i<=2; i++ )//123 + 345 + 567 + 789
					    if( info[i][1]==1 && info[i][2]==1 && info[i][3]==2 && info[i][4]==1 && info[i][5]==2 && 
						    info[i][6]==1 && info[i][7]==2 && info[i][8]==1 && info[i][9]==1 )
								    num[0] = 1;
									
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("一色四步高："+IsExist(num[0]) );
					
					break;
				}
				
				case SanGang://17.三：前置66.暗、73.明，成立1，不成立0。
				{
				    if( chiPeng==0 ) 
					    {
						    break;
						}
					    else
						{
				            for( int i=0; i<chiPeng/3; i++ )
					            {
						            if( source[i*3+1]==-10 || source[i*3+1]==-11 )//明暗
									    {
										    num[0]++;
										}
						        }
						}
					if( num[0] > 2 ) num[0] = 1;
					    else num[0] = 0;
					break;
				}
				
				case QiDui://18.七Γ翰豢沙耘觯手牌4一赢做2Γ档亩际侨迸(不入符合)
				{
				    if( chiPeng > 0 ) break;
					int dui = 0;//
					for( int i=0; i<4; i++ )//f筒l字
					    {
						    for( int j=1; j<info[i].length; j++ )
							    {
									//if( info[i][j] == 1 ) 
									    //{
										    //num[y] = i*10 + j -1;//缺牌
											//if(y==28)System.out.println("!!!!!!!");
											//y++;
										//}
										//else 
										if( info[i][j] == 2 ) 
									    {
										    dui++;
										}
									    else if( info[i][j] == 3 ) 
									    {
										    dui++;
											//num[y] = i*10 + j -1;//缺牌
											//if(y==28)System.out.println("!!!!!!!");
											//y++;
										}
									    else if( info[i][j] == 4 ) 
									    {
										    dui = dui + 2;
										}
								}
						}
					num[0] = dui*2;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("七Ψ合:"+num[0]);
				    break;
				}
				
				case QiXingBuKao://19.七星不靠，33.全不靠成立後，看字牌是否R全，成立1，不成立0。
				{
				    int count = 0;
						    for( int j=1; j<=7; j++ )//|到白
							    {
									if( info[3][j] > 0 )//有字牌
										{
											 count++;
										}
								}
					if( count==7 )
					    {
						    num[0] = 1;
						}
					break;
				}
				
				case QuanShuangKe://20.全p刻：前置47.碰碰和，成立1，不成立0。
				{
				    num[0] = 1;
				    for( int i=0; i<source.length; i++ )
					    {
						    if( source[i] >=30 || source[i]%2==0 )//字或悼
							    {
								    num[0] = 0;
									break;
								}
						}
					break;
				}
				
				case QingYiShai://21.清一色，回髦0-14
				{
					int CPCate = -1;
					boolean fail = false;
					if( chiPeng > 0 )
					    {
						    for( int i=0; i<chiPeng/3; i++ )
							    {
								    if( i==0 && source[i*3] < 30 ) CPCate = source[i*3]/10;//若只吃碰一M，非字，以此花色
									else if( i > 0 && ( source[i*3]/10 != CPCate ) )//若吃碰2M，花色不相同
									    {
										    fail = true;//不成立
										}
								}
						}
						
					if( fail ) break;
					
					int[] qing = { 0, 0, 0 };//f筒l的盗
				    for( int i=0; i<14; i++ )
					    {
						    if( source[i] == -10 || source[i] == -11 )//
							    {
								    source[i] = source[i+1];//牌中g的牌DQ苏I
								}
							int cate = source[i]/10;
							
						    if( cate <= 2 ) qing[cate]++;
						}
						
					int max = 0;
					if( CPCate == -1 )//花色未_定
					    {
							max = qing[0];
							if( qing[0] < qing[1] ) { max = qing[1]; CPCate = 1; }
							if( max < qing[2] ) { max = qing[2]; CPCate = 2; }
						}
						else//花色已_定
						{
						    max = qing[CPCate];
						}
					
					for( int i=0; i<=8; i++ )//CPCate的序1-9缺牌
					    {
						    if( i<=6 )
							num[y] = CPCate*10 + i;
							y++;
						}
						
					for( int i=0; i<source.length; i++ )//不同花色U牌
					    {
						    if( source[i]/10 != CPCate )
							    {
								    num[x] = source[i];
									x++;
								}
						}
						
					num[0] = max;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("清一色符合:"+num[0]);
					break;
				}
				
				case YiShaiSanTongShun://22一色三同
				{
				    if( chiPeng > 0 )
					    {
						    int peng = 0;
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] == source[i*3+2] )//有碰
								    {
									    peng++;
									}
									else//有吃，把Y料塞回P表
								    {
									    for( int j=0; j<3; j++ )
										    {
											    int a = source[i*3+j]/10;
												int b = source[i*3+j]%10+1;
												info[a][b] = info[a][b] + 1;
											}
									}
						    }
							if( peng >= 2 )//2M碰，一色三同o法成立
							{
							    break;
							}
						}
					
					int sum = 0;
				    for(int i=0; i<=2; i++)//f筒l
					    {
						    for(int j=1; j<=7; j++)//123.234.345......789
							{
							    sum = info[i][j] + info[i][j+1] + info[i][j+2];
								if( sum > num[0] )
								    {
									    num[0] = sum;
									}
								sum = 0;
							}
						}
					num[0] = num[0] + CONST_CUSTOMIZE.checkOnece_9_PLUS;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("一色三同符合:"+num[0]);
					break;
				}
				
				case YiShaiSanJieGao://23.一色三高，o缺U牌，返回0-9
                {
				    if( chiPeng > 0 )
					    {
						    int chi = 0;
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] != source[i*3+2] )//有吃
								    {
									    chi++;
									}
									else//有碰，把Y料塞回P表
								    {
										int a = source[i*3]/10;
										int b = source[i*3]%10+1;
										info[a][b] = info[a][b] + 3;//也算3
									}
						    }
							if( chi >= 2 )//2M吃，一色三高o法成立
							{
							    break;
							}
						}
						
				    int sum = 0;
				    for(int i=0; i<=2; i++)//f筒l
					    {
						    for(int j=1; j<=7; j++)//123.234.345......789
							{
							    int a = info[i][j]   > 1 ? info[i][j]   : 0;//不
							    int b = info[i][j+1] > 1 ? info[i][j+1] : 0;
							    int c = info[i][j+2] > 1 ? info[i][j+2] : 0;
							    sum = a + b + c;
								if( sum > num[0] )
								    {
									    num[0] = sum;
									}
								sum = 0;
							}
						}
					num[0] = num[0] + CONST_CUSTOMIZE.checkOnece_9_PLUS;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("一色三高符合:"+num[0]);
				    break;
				}
				
				case QuanDai://24.全大，大於五成立後，z查是否有序6的牌，成立1，不成立0。
				{
				    num[0] = 1;
				    for( int i=0; i<14; i++ )
					    {
						    if( source[i]%10 == 5 )
							    {
								    num[0] = 0;
								    break;
								}
						}
					break;
				}
				
				case QuanZhong://25.全中，全五成立後，z查是否有序3.7的牌，成立1，不成立0。
				{
				    num[0] = 1;
				    for( int i=0; i<14; i++ )
					    {
						    if( source[i]%10 == 2 || source[i]%10 == 6 )
							    {
								    num[0] = 0;
								    break;
								}
						}
					break;
				}
				
				case QuanXiao://26.全小，小於五成立後，z查是否有序4的牌，成立1，不成立0。
				{
				    num[0] = 1;
				    for( int i=0; i<14; i++ )
					    {
						    if( source[i]%10 == 3 )
							    {
								    num[0] = 0;
								    break;
								}
						}
					break;
				}
				
				case QingLong://27.清：吃的要123.456.789，手牌可任意M合
				{
				    boolean bl[][] = new boolean[3][9];
					if( chiPeng > 0 )
					    {
						    int cp = chiPeng / 3;//吃碰M担此至少1
						    for( int i=0; i<cp; i++)
							    {
								    if( source[i*3] != source[i*3+2] )//吃碰M的^不等於尾 => 吃
									    {
											int head = source[i*3];//找^
											if( source[i*3] > source[i*3+1] )  head = source[i*3+1];
											if( head > source[i*3+2] )  head = source[i*3+2];
											if( head%10==0 )//1f、1筒、1l
											    {
												    bl[head/10][0] = true;
													bl[head/10][1] = true;
													bl[head/10][2] = true;
												}
												else if( head%10==3 )//4f、4筒、4l
												{
												    bl[head/10][3] = true;
													bl[head/10][4] = true;
													bl[head/10][5] = true;
												}
												else if( head%10==6 )//7f、7筒、7l
												{
												    bl[head/10][6] = true;
													bl[head/10][7] = true;
													bl[head/10][8] = true;
												}
										}
								}
						}
					for( int j=chiPeng; j<source.length; j++ )//算手牌
						{
							if( source[j]/10 < 3 )
							    {
								    bl[source[j]/10][source[j]%10] = true;
								}
						}
					int sum = 0;
					for( int k=0; k<3; k++ )
					    {
						    for( int m=0; m<9; m++ )
							    {
								    if( bl[k][m] == true )
									    sum++;
								}
							if( sum > num[0] )
							    {
								    num[0] = sum;
								}
							sum =0;
						}
					num[0] = num[0] + CONST_CUSTOMIZE.checkOnece_9_PLUS;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("清符合:"+num[0]);
				    break;
				}
				
				case SanShaiShuangLongHui://28.三色p：缮的123+789+第三色的55
				{
				    boolean fail = false;
					int[][] chiHead = new int[3][2];//f筒l的123+789
				    if( chiPeng > 0 )
					    {
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] == source[i*3+2] )//有碰
								    {
									    fail = true;
										break;
									}
									else//有吃，若o序46，^
								    {
									    for( int j=0; j<3; j++ )//z查吃M有o序46，有t中啵ot塞入P表
										    {
										        if( source[i*3+j]%10==3 || source[i*3+j]%10==5 )
												    {
													    fail = true;
														break;
													}
											}
											
										if( fail ) 
										    {
											    break;
											}
											else
											{
											    for( int j=0; j<4; j++ )//找出^K
												    {
														int hd = source[i*3];
														if( hd > source[i*3+1] ) hd=source[i*3+1];
														if( hd > source[i*3+2] ) hd=source[i*3+2];
														if( hd%10==0 ) chiHead[hd/10][0]++;
														    else if( hd%10==6 ) chiHead[hd/10][1]++;
													}
											}
									}
						    }
							if( fail ) break;
						}
					
				    for( int i=0; i<=2; i++ )//55是f筒l那一N
					    {
						    int[] temp = {
                      					   0,
		                                  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
					                      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
							  		     };
							int temp_x = 1;
							int temp_y = 15;
							int sum = 0;
							if( info[i][5] < 2 )//缺5
							    {
								    for( int j=2; j>2-info[i][5]; j-- )
									    {
								    	    temp[temp_y] = i*10+4;
										    temp_y++;
											sum = sum + 1;
										}
								}
								else if( info[i][5] == 2 )
								{
									sum = sum + 2;
								}
								else if( info[i][5] > 2 )//多5
								{
									sum = sum + 2;
									for( int j=0; j<info[i][5]-2; j++ )
									    {
								    	    temp[temp_x] = i*10+4;
										    temp_x++;
										}
								}
								
							for( int j=1; j<=9; j++ )//123+789
							    {
								    for( int k=0; k<=2; k++ )//z查剩下2N花色的123+789
									    { 
										    if( k==i ) continue;//跟55同花色的z查跳^
											if( chiHead[k][0]>0 )//此花色的123已吃了
											    {
												    if( j==1 || j==2 ) continue;//跳^
													if( j==3 )
													    {
														    sum = sum + 3;
															continue;//跳^
														}
												}
											if( chiHead[k][1]>0 )//此花色的789已吃了
											    {
												    if( j==7 || j==8 ) continue;//跳^
													if( j==9 )
													    {
														    sum = sum + 3;
															continue;//跳^
														}
												}
								    	    if( info[k][j] > 0 && ( j<=3 || j>=7 ) )//未吃^123+789，算手牌存在盗
											    {
												    sum++;
													if( info[k][j] > 1 )//多的全U牌
													    {
														    for( int p=0; p<info[k][j]-1; p++ )
															    {
																    temp[temp_x] = k*10 + j - 1;
										    				        temp_x++;
																}
														}
												}
												else if( info[k][j] == 0 && ( j<=3 || j>=7 ) )//缺牌
												{
								    			    temp[temp_y] = k*10 + j - 1;
												    temp_y++;
												}
												else if( info[k][j] > 0 && ( j>=4 || j<=6 ) )//U牌
												{
												    temp[temp_x] = k*10 + j - 1;
										    		temp_x++;
												}
										}
								}
								
							if( sum > num[0] )
							    {
								    num[0] = sum;
									for( int j=1; j<num.length; j++ )
									    {
										    num[j] = temp[j];
										}
								}
						}
					break;
				}
				
				case YiShaiSanBuGao://29.一色三步高：49.三色三步高的紊版，返回0-9，有缺牌
				{
				    int[][] shun = new int[3][7];//f筒l字7N的盗
				    if( chiPeng > 0 )
					    {
						    int peng = 0;
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] == source[i*3+2] )//有碰
								    {
									    peng++;
									}
									else//有吃，吃的^
								    {
										int head = source[i*3];
										if( source[i*3+1] < head ) head = source[i*3+1];
										if( source[i*3+2] < head ) head = source[i*3+2];
										shun[head/10][head%10]++;
									}
						    }
							if( peng >= 2 )//2M碰，三步高o法成立
							{
							    break;
							}
						}
					
					int sum = 0;
				    for(int i=0; i<3; i++)//f筒l
					    {
						    for(int j=1; j<=5; j++)//^ 123.234.345.456.567
							{
							    int[] temp = {
                      						   0,
		                                      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
					                          -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
											  };
								int temp_x = 1;
								int temp_y = 15;
								int[][] infoTmp = new int[4][11];
		                            for( int jj=0; jj<info.length; jj++ )
				                        {
					                        System.arraycopy(info[jj], 0, infoTmp[jj], 0, info[jj].length);
				                        }
								
							    for( int s=0; s<3; s++ )
								    {
									    for( int t=0; t<3; t++ )// 序=> 123 + 234 + 345
										    {
											    if( shun[i][j+s-1] > 0 )//此已有吃了
												    {
													    sum = sum + 3;
														break;
													}
											    int w = ( infoTmp[i][0+j+s+t] > 0 ) ? 1 : 0;
												sum = sum + w;
												if( w==1 )
												    {
													    infoTmp[i][0+j+s+t]--;
													}
													else if( w==0 )
												    {
													    temp[temp_y] = s*10 + j + s + t -1;//入缺牌
														temp_y++;
													}
											}
									}
								if( sum > num[0] )
								    {
									    num = temp;
									    num[0] = sum;
									}
								sum = 0;
							}
							
							for(int j=1; j<=3; j++ )//^ 135.246.357
							{
							    int[] temp = {
                      						   0,
		                                      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
					                          -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
											  };
								int temp_x = 1;
								int temp_y = 15;
								int[][] infoTmp = new int[4][11];
		                            for( int jj=0; jj<info.length; jj++ )
				                        {
					                        System.arraycopy(info[jj], 0, infoTmp[jj], 0, info[jj].length);
				                        }
										
							    for( int s=0; s<3; s++ )
								    {
									    for( int t=0; t<3; t++ )//  idx[0]	的序：f筒l => 123f+345筒+567l
										    {
											    if( shun[i][j+s*2-1] > 0 )//此已有吃了
												    {
													    sum = sum + 3;
														break;
													}
											    int w = ( infoTmp[i][0+j+s*2+t] > 0 ) ? 1 : 0;
												sum = sum + w;
												if( w==1 )
												    {
													    infoTmp[i][0+j+s*2+t]--;
													}
													else if( w==0 )
												    {
													    temp[temp_y] = s*10 + j + s + t -1;//入缺牌
														temp_y++;
													}
											}
									}
								if( sum > num[0] )
								    {
									    num = temp;
									    num[0] = sum;
									}
								sum = 0;
							}
						}
					num[0] = num[0] + CONST_CUSTOMIZE.checkOnece_9_PLUS;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(Fan[29]+"符合:"+num[0]);
					break;
				}
				
				/*case QuanDaiWu://30.全五：禁碰字、禁碰非五、禁吃含1289>>>>>>>>>>>>可以胡牌了再z查，AIy做= =
				{
					int[] head = { -1, -1, -1, -1 };//最多四M吃的^楹?，345f3f、567筒5筒
					int[] shun = { 0, 0, 0};//f筒l的
					boolean pengWan = false;//碰N楹?f筒l?
					boolean pengTong = false;
					boolean pengTiao = false;
					
				    if( chiPeng > 0 )
					    {
						    boolean fail = false;
							
				            for( int i=0; i<chiPeng/3; i++ )
					    	    {
						    	    int qdw = source[i] % 10;
						    	    if( source[i*3] >= 30 ) fail = true;//禁碰字
								    if( (source[i*3] == source[i*3+2]) && qdw != 4 ) fail = true;//禁碰非五
							    }
							if( !fail )
							    {
									for( int i=0; i<chiPeng; i++ )
					    	    	    {
						    	 	        int qdw = source[i] % 10;
									    	if( qdw == 0 || qdw == 1 || qdw == 7 || qdw == 9 ) //禁吃含1289
											    {
												    fail = true;
													break;
												}
							    	    }
								}
							
							if( fail ) break;
							
							if( !fail ) //绦兄链耍吃碰都是有5，z查已吃碰的555刻.345.456.567，p少下方z查
							    {
								    num[0] = num[0] + chiPeng;
									for( int p=chiPeng; p<source.length; p++ )
													    {
														    if( source[p]<30 && source[p]%10>1 && source[p]%10<7 )
															    {
																    num[0]++;
																}
																else
																{
																    num[x] = source[p];//入U牌
														            x++;
																}
														}
								    for( int i=0; i<chiPeng/3; i++ )
					    	    	    {
								    	    if( source[i] == source[i+2] )//碰555
											    {
												    int peng = source[i] / 10;
												    switch( peng )
													    {
														    case 0:{
															    pengWan = true;
															    break;}
																
														    case 1:{
															    pengTong = true;
															    break;}
																
														    case 2:{
															    pengTiao = true;
															    break;}
																
															default:{
															    System.out.println("全五已碰牌z查e`：peng = "+peng);
															    break;}
														}
												}
												else//此M槌裕找出^
												{
												    int tou = source[i];
													if( source[i] > source[i+1] ) tou = source[i+1];
													if( tou > source[i+2] ) tou = source[i+2];
													head[i] = tou;
													shun[source[i]/10]++;//N的加1
												}
							    	    }
								//}
								
						//}
					
				    int[][] idx = {
					                {0,1,2,},//f筒l
					                {0,2,1,},//fl筒
					                {1,0,2,},//筒fl
					                {1,2,0,},//筒lf
					                {2,0,1,},//lf筒
					                {2,1,0,},//l筒f
					              };
				    int[][] combo = 
					    {
						    {0,0,0,3,1,1},//A      //花色A序5的刻 + 花色A序5的 + 花色B序5的刻 +花色B序5的 + 花色C序5的⒀ + 花色C序5的怠３淌剿愠淼摹
                            {0,0,0,4,1,0},//B
                            {0,1,0,2,1,1},//C
                            {0,1,0,3,1,0},//D
                            {0,1,1,1,1,1},//E
                            //{0,2,0,1,1,1},//C
                            {0,2,0,2,1,0},
                            {0,2,1,0,1,1},//F
                            {0,2,1,1,1,0},//G
                            //{0,3,0,0,1,1},//A
                            //{0,3,0,1,1,0},//D
                            {0,3,1,0,1,0},//H
                            //{0,4,0,0,1,0},//B
                            //{1,0,0,2,1,1},//F
                            //{1,0,0,3,1,0},//H
                            {1,0,1,1,1,1},//I
                            //{1,1,0,1,1,1},//E
                            //{1,1,0,2,1,0},//G
                            //{1,1,1,0,1,1},//I
                            {1,1,1,1,1,0}
						};
						
					//int max = 0;//最大符合
					//int maxFei[] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,};//U牌
					//int maxQue[] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,};//缺牌
					//int temp = 0;//捍娴姆合
					//int temp2 = 0;//捍娴姆合2
					for( int i=0; i<combo.length; i++ )//z查何N<<全五M合>>
					    {
						    for( int j=0; j<idx.length; j++ )//使用何Mcate( f筒l序 )
							    {
								    boolean stop = false;
								    int[] cate = idx[j];
									for( int k=0; k<cate.length; k++ )//依cate的花色序z查combo[i] 的  0.1 + 2.3 + 4
									    {
										    //for( int m=0; m<combo[i].length; m++ )//依序z查combo 第二S的
											    //{
												    //已吃碰盗咳舫出要求，t不用算，若未超出，t加入符合
												    if( cate[k]==0 )//cate 序z查f
											    	    {
												            if( pengWan )//已有碰f刻子
															    {
																    if( k!=2 && combo[i][k*2]==0 )//k=2.k*2.是⒀  、  z查f刻子的盗恳0
																	    {
																		    stop = true;
																		    break;//此M花色序不用z查，因榕鋈f刻子已不符此M合l件
																		}
																		else if( k!=2 && combo[i][k*2]==1 )
																		    {
																			    temp = temp + 3;
																			}
																}
															if( shun[0] > 0 )//已吃ㄧf子以上
															    {
																    if( combo[i][k*2+1]<shun[0] )//f盗看箪侗矶ㄐ枰的
																	    {
																		    stop = true;
																		    break;//此M花色序不用z查，因槿f子盗恳殉出此M合l件
																		}
																		else
																		{
																		    temp = temp + shun[0]*3;
																		}
																}
													    }
													    else if( cate[k]==1 )//cate 序z查筒
											    	    {
												            if( pengTong )//已有碰筒刻子
															    {
																    if( k!=2 && combo[i][k*2]==0 )//k=2.k*2.是⒀  、  z查筒刻子的盗恳0
																	    {
																		    stop = true;
																		    break;//此M花色序不用z查，因榕鐾部套右巡环此M合l件
																		}
																		else if( k!=2 && combo[i][k*2]==1 )
																		    {
																			    temp = temp + 3;
																			}
																}
															if( shun[1] > 0 )//已吃ㄧ筒子以上
															    {
																    if( combo[i][k*2+1]<shun[0] )//筒盗看箪侗矶ㄐ枰的
																	    {
																		    stop = true;
																		    break;//此M花色序不用z查，因橥岔子盗恳殉出此M合l件
																		}
																		else
																		{
																		    temp = temp + shun[0]*3;
																		}
																}
													    }	
													    else if( cate[k]==2 )//cate 序z查l
											    	    {
												            if( pengTiao )//已有碰l刻子
															    {
																    if( k!=2 && combo[i][k*2]==0 )//k=2.k*2.是⒀  、  z查l刻子的盗恳0
																	    {
																		    stop = true;
																		    break;//此M花色序不用z查，因榕l刻子已不符此M合l件
																		}
																		else if( k!=2 && combo[i][k*2]==1 )
																		    {
																			    temp = temp + 3;
																			}
																}
															if( shun[2] > 0 )//已吃ㄧl子以上
															    {
																    if( combo[i][k*2+1]<shun[0] )//l盗看箪侗矶ㄐ枰的
																	    {
																		    stop = true;
																		    break;//此M花色序不用z查，因l子盗恳殉出此M合l件
																		}
																		else
																		{
																		    temp = temp + shun[0]*3;
																		}
																}
													    }	
										    	    
													//M行至此，刻都未超出表的要求，_始M行未吃碰部份的符合涤算
													
													//k = 0 ：z查花色cate[0] 是否有 combo[i][0]*3 的的
												    //k = 0 ：z查花色cate[0] 是否有 combo[i][1] 的5盗浚最高符合combo[i][1] *3，若o，最高符合楹?
										    	    //k = 1 ：z查花色cate[1] 是否有 combo[i][2]*3 的的
												    //k = 1 ：z查花色cate[1] 是否有 combo[i][3] 的5盗浚最高符合combo[i][3] *3，若o，最高符合楹?
												    //k = 2 ：z查花色cate[2] 是否有 combo[i][4] 的5盗浚最高符合combo[i][4] *3，若o，最高符合楹?
										   	        //k = 2 ：z查花色cate[2] 是否有 2⒀
													
													//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<偷= =找不到m合的演算法，只好3-7的f筒l都算是符合>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
													
												//}
										    if( stop ) break;//下一花色M合
										}
								}
						}
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(Fan[30]+"符合:"+num[0]);
					break;
				}*/
				
				case SanTongKe://31;三同刻：前置64.p同刻
				{
				    int[][] stk = new int[3][9];
					for(int i=0; i<hu.length/3; i++)
					    {
						    if( hu[i*3]<30 && hu[i*3]==hu[i*3+2] )
							    {
								    stk[hu[i*3]/10][hu[i*3]%10]++;//o刻子盗颗ce
								}
						}
					
					int sum = 0;
					for(int j=0; j<=8; j++)//序
						{
						    if( stk[0][j]==1 && stk[1][j]==1 && stk[2][j]==1 )//序奠度花色各有一刻子
							    num[0] = 1;
						}
					break;
				}
				
				case SanAnKe://32.三暗刻，成立1，不成立0。
				{
				    int sak = 0;
					int sak2 = 0;
					int sak3 = 0;
				    if( chiPeng > 0 )//z查暗
					    {
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( hu[i*3+1] == -11 )//是暗
								    {
									    sak++;
									}
						    }
						}
					
					for( int i=chiPeng/3; i<hu.length/3; i++ )
					    {
						    if( hu[i*3]==hu[i*3+2] ) sak2++;
						}
					for( int i=0; i<=3; i++ )//四花色
					    {
						    for( int j=1; j<=9; j++ )
							    if( info[i][j]>=3 )//111222333=>123123123，所以要z查手牌
							        {
								        sak3++;
								    }
						}
					if( sak2 > sak3 ) sak = sak + sak2;
					    else sak = sak + sak3;
					if( sak >= 3 ) num[0] = 1;
						else num[0] = 0;
					break;
				}
				
				case QuanBuKao://33全不靠：34M合+7N字=只缺2，成立後z查19.七星不靠是否成立
				{
				    if( chiPeng > 0 ) break;//有吃碰就o法成立
					
					int[][] idx = {//配合下方圈，z查序1-9即可得知147+258+369符合
					                {0,1,2,0,1,2,0,1,2,},//f筒l
					                {0,2,1,0,2,1,0,2,1,},//fl筒
					                {1,0,2,1,0,2,1,0,2,},//筒fl
					                {1,2,0,1,2,0,1,2,0,},//筒lf
					                {2,0,1,2,0,1,2,0,1,},//lf筒
					                {2,1,0,2,1,0,2,1,0,},//l筒f
					              };
					
					int max = 0;//147+258+369最大符合
					int maxFei[] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,};//U牌
					int maxQue[] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,};//缺牌
					int temp = 0;//捍娴姆合
					for( int i=0; i<6; i++ )//idx的6N花色M合
					    {
						    int[] fp = new int[14];
							for( int r=0; r<14; r++) fp[r] = source[r];
							int[] qp = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,};//捍嫒迸
				            for( int j=1; j<=9; j++ )//序1-9
					            {
						            int k = idx[i][j-1];//要z查的花色
								    if( info[k][j] > 0 )
								        {//有
									        temp++;
											for( int m=0; m<fp.length; m++ )//自捍骊列中移除已有的牌
											    {
												    if( fp[m] == k*10+j-1 )
													    {
														    fp[m] = -1;
															break;
														}
												}
									    }
										else//]有
										{
										    for( int m=0; m<qp.length; m++ )
											    {
												    if( qp[m] == -1 )
													    {
														    qp[m] = k*10+j-1;
														}
												}
										}
						        }
								
							if( temp > max ) //若此M合之符合荡箪赌壳白畲蠓合担取代之
							    {
								    max = temp;
									maxFei = fp;
									maxQue = qp;
								}
							temp = 0;
						}
					
					num[0] = max;
					//理缺U列
					for( int i=1; i<=28; i++ )
					    {
						    if( i<15 )
							    {
								    num[i] = maxFei[i-1];
								}
								else
								{
								    num[i] = maxQue[i-15];
								}
						}
					//z查七N字，都有就是七星
					int count = 0;
						    for( int j=1; j<=7; j++ )//|到白
							    {
											if( info[3][j] > 0 )//有字牌
											    {
												    count++;
													if( info[3][j] > 1 )//字牌有2以上
												    for( int k=1; k<info[3][j]; k++ )//入U牌
													    {
														    for( int r=1; r<=14; r++ )
															    {
																    if( num[r] == -1 )
																	    {
																		    num[r] = 30 + j - 1;
																			break;
																		}
																}
														}
												}
								}
						
					num[0] = num[0] + count;
					
					/*System.out.println("全不靠U牌=");
					for( int i=1; i<15; i++ )
					{
					try{
					if( num[i]!=-1 )
					System.out.print(word[num[i]]+"  _");
					}catch(Exception e){ System.out.println("EEXX= i =>"+i+"__num[i]="+num[i]); }
					}*/
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(Fan[33]+"符合:"+num[0]);
			        break;
				}
				
				//此M合方法目前只m用在全不靠成立後的z查，一般情r下要用LGame.TMDZuHeLong()
				case ZuHeLong://34.M合147+258+369，U牌、缺牌是147、258、369而言
				{
				    if( chiPeng > 3 ) break;//吃碰超^1M就o法成立
					
					int[][] idx = {//配合下方圈，z查序1-9即可得知符合
					                {0,1,2,0,1,2,0,1,2,},//f筒l
					                {0,2,1,0,2,1,0,2,1,},//fl筒
					                {1,0,2,1,0,2,1,0,2,},//筒fl
					                {1,2,0,1,2,0,1,2,0,},//筒lf
					                {2,0,1,2,0,1,2,0,1,},//lf筒
					                {2,1,0,2,1,0,2,1,0,},//l筒f
					              };
								  
					int max = 0;//最大符合
					int maxFei[] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,};//U牌
					int maxQue[] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,};//缺牌
					int temp = 0;//捍娴姆合
					for( int i=0; i<6; i++ )//idx的6N花色M合
					    {
						    int[] fp = new int[14];
							for( int r=0; r<14; r++) fp[r] = source[r];
							int[] qp = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,};//捍嫒迸
				            for( int j=1; j<=9; j++ )//序1-9
					            {
						            int k = idx[i][j-1];//要z查的花色
								    if( info[k][j] > 0 )
								        {//有
									        temp++;
											for( int m=0; m<fp.length; m++ )//自捍骊列中移除已有的牌
											    {
												    if( fp[m] == k*10+j-1 )
													    {
														    fp[m] = -1;
															break;
														}
												}
									    }
										else//]有
										{
										    for( int m=0; m<qp.length; m++ )
											    {
												    if( qp[m] == -1 )
													    {
														    qp[m] = k*10+j-1;
														}
												}
										}
						        }
								
							//int ck = checkLeftPai(fp);//剩N牌中3+2M合的最大值
							//System.out.println("ck="+ck);
							//if( temp + ck > max ) //若此M合之符合荡箪赌壳白畲蠓合担取代之
							if( temp > max ) //若此M合之符合荡箪赌壳白畲蠓合担取代之
							    {
								    //max = temp + ck;
								    max = temp;
									maxFei = fp;
									maxQue = qp;
								}
							temp = 0;
						}
						
					num[0] = max;
					//理缺U列
					for( int i=1; i<=28; i++ )
					    {
						    if( i<15 )
							    {
								    num[i] = maxFei[i-1];
								}
								else
								{
								    num[i] = maxQue[i-15];
								}
						}
					num[0] = num[0] + CONST_CUSTOMIZE.checkOnece_9_PLUS;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(Fan[34]+"符合:"+num[0]);
			        break;
				}
				
				case DaiYuWu://35.大於五：序荡箪5的都是缺牌
				{
					boolean fail = false;
				    if( chiPeng > 0 )//有吃碰 => z查明牌
					    {
						    for( int i=0; i<chiPeng; i++)
							    {
								    if( source[i]%10 < 5 || source[i]/10 == 3 )//吃碰序12345或是字 => 不成立
									    {
										    fail = true;
										    break;
										}
								}
						}
						
					if( fail ) break;
					num[0] = num[0] + chiPeng;//绦兄链耍表示指之前都符合
					
					for( int i=0; i<4; i++ )//z查手牌f筒l字
					    {
						
					    for( int j=1; j<=9; j++ )//各序
						    {
							    if( i < 3 && j > 5 && info[i][j] > 0 )//f筒l序大於5
								    {
									    num[0] = num[0] + info[i][j];
									}
									else if( ((i<3 && j<=5)||(i==3)) && info[i][j] > 0 )//f筒l序小於等於5，或是字
									{
									    num[x] = i*10 + (j-1);//入U牌
									    x++;
									}
							}
						}
							
					for( int i=0; i<3; i++ )//f筒l序 > 5，都是缺牌
					    for( int j=6; j<10; j++ )
					        {
						        num[y] = i*10 + (j-1);//缺一，入缺牌
							    y++;
						    }
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(Fan[35]+"符合:"+num[0]);
			        break;
				}
				
				case XiaoYuWu://36.小於五：序敌§5的都是缺牌
				{
					boolean fail = false;
				    if( chiPeng > 0 )//有吃碰 => z查明牌
					    {
						    for( int i=0; i<chiPeng; i++)
							    {
								    if( source[i]%10 > 3 || source[i]/10 == 3 )//吃碰序56789或是字 => 不成立
									    {
										    fail = true;
										    break;
										}
								}
						}
						
					if( fail ) break;
					num[0] = num[0] + chiPeng;//绦兄链耍表示指之前都符合
						
					for( int i=0; i<4; i++ )//z查手牌f筒l字
					    for( int j=1; j<=9; j++ )//各序
						    {
							    if( i < 3 && j < 5 && info[i][j] > 0 )//f筒l序小於5
								    {
									    num[0] = num[0] + info[i][j];
									}
									else if(  ((i<3 && j>=5)||(i==3)) && info[i][j] > 0 )//f筒l序大於等於5，或是字
									{
									    num[x] = i*10 + (j-1);//入U牌
									    x++;
									}
							}
							
					for( int i=0; i<3; i++ )//f筒l序 < 5，都是缺牌
					    for( int j=1; j<5; j++ )
					        {
						        num[y] = i*10 + (j-1);//缺一，入缺牌
							    y++;
						    }
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(Fan[36]+"符合:"+num[0]);
			        break;
				}
				
				case SanFengKe://37.三L刻，胡了再z查有o0.大四喜、8.小四喜
				{
				    if( chiPeng > 0 )
					    {
						    int chi = 0;
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] != source[i*3+2] )//有吃
								    {
									    chi++;
									}
									else
								    {
										if( source[i*3]>=30 && source[i*3]<=33 )//有L刻
										    num[0] = num[0] + 3;
									}
						    }
							if( chi >= 2 )//2M吃，o法成立
							{
							    break;
							}
						}
					
					for( int i=1; i<=4; i++ )
					    {
						    if( info[3][i]>1 )//手牌未吃碰同L牌有2以上
							    num[0] = num[0] + info[3][i];
						}
					num[0] = num[0] + CONST_CUSTOMIZE.checkOnece_9_PLUS;
					break;
				}
				
				case HuaLong://38.花：49.三色三步高差距3的版本，返回0-9，有缺牌
				{
				    int[][] shun = new int[3][7];//f筒l字7N的盗
				    if( chiPeng > 0 )
					    {
						    int peng = 0;
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] == source[i*3+2] )//有碰
								    {
									    peng++;
									}
									else//有吃，吃的^
								    {
										int head = source[i*3];
										if( source[i*3+1] < head ) head = source[i*3+1];
										if( source[i*3+2] < head ) head = source[i*3+2];
										shun[head/10][head%10]++;
									}
						    }
							if( peng >= 2 )//2M碰，花o法成立
							{
							    break;
							}
						}
						
					int[][] idx = {//配合下方圈，可得知符合
					                {0,1,2,},//f筒l
					                {0,2,1,},//fl筒
					                {1,0,2,},//筒fl
					                {1,2,0,},//筒lf
					                {2,0,1,},//lf筒
					                {2,1,0,},//l筒f
					              };
					int sum = 0;
					for(int i=0; i<6; i++)//idx 6M
					    {
						        int[] k = idx[i];
							    int[] temp = {
                      						   0,
		                                      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
					                          -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
											  };
								int temp_x = 1;
								int temp_y = 15;
								
							    for( int s=0; s<3; s++ )
								    {
									    for( int t=0; t<3; t++ )//  idx[0]	的序：f筒l => 123f+456筒+789l
										    {
											    if( shun[k[s]][s*3] > 0 )//此已有吃了
												    {
													    sum = sum + 3;
														break;
													}
											    int w = ( info[k[s]][0+1+s*3+t] > 0 ) ? 1 : 0;
												sum = sum + w;
												if( w==0 )
												    {
													    temp[temp_y] = s*10 + 1 + s + t -1;//入缺牌
														temp_y++;
													}
											}
									}
								if( sum > num[0] )
								    {
									    num = temp;
									    num[0] = sum;
									}
								sum = 0;
						}
					num[0] = num[0] + CONST_CUSTOMIZE.checkOnece_9_PLUS;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(Fan[38]+"符合:"+num[0]);
					break;
				}
				
				case TuiBuDao://39.推不倒：1234589筒 + 245689l + 白板，有U牌，o缺牌
				{
				    for( int i=0; i<source.length; i++ )
					    {
						    int s = source[i];
							if( s == -10 || s == -11 ) s = source[i+1];//牌苏IDQ
						    if( s==10 || s==11 || s==12 || s==13 || s==14 || s==17 || s==18 || s==21 || s==23 || s==24 || s==25 || s==27 || s==28 || 
							    (s==36&&info[3][6]>1) )
							    {
									if( s!=36 ) num[0]++;
									    else num[0] = num[0] + info[3][6];//白板要2才算
								}
								else
								{
								    num[x] = s;//入U牌
									x++;
								}
						}
					num[15] = 10;  num[16] = 11;  num[17] = 12;  num[18] = 13;  num[19] = 14;  num[20] = 17;  num[21] = 18;
					num[22] = 21;  num[23] = 23;  num[24] = 24;  num[25] = 25;  num[26] = 27;  num[27] = 28;  num[28] = 36;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(Fan[39]+"符合:"+num[0]);
			        break;
				}
				
				case SanShaiSanTongShun://40.三色三同 ，有缺牌，oU牌
				{
				    int[][] shun = new int[3][7];//f筒l7N的盗
				    if( chiPeng > 0 )
					    {
						    int peng = 0;
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] == source[i*3+2] )//有碰
								    {
									    peng++;
									}
									else//有吃，吃的^
								    {
										int head = source[i*3];
										if( source[i*3+1] < head ) head = source[i*3+1];
										if( source[i*3+2] < head ) head = source[i*3+2];
										shun[head/10][head%10]++;
									}
						    }
							if( peng >= 2 )//2M碰，三色三同o法成立
							{
							    break;
							}
						}
					/*以下ふ胰花色的123、三花色的234、三花色的345......、*/
					for( int i=1; i<=7; i++ )//1-7的^
					    {
						    int sum = 0;
							int[] temp = {
                      					   0,
		                                  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
					                      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
										  };
							int temp_x = 1;//U牌索引
							int temp_y = 15;//缺牌索引
							
						    for( int j=0; j<=2; j++ )//3花色
							    {
								    if( shun[j][i-1] > 0 )//此花色之已有吃了
										{
											sum = sum + 3;
										}
										else
										{
										    sum = info[j][i]  >0 ? sum+1 : sum;
											sum = info[j][i+1]>0 ? sum+1 : sum;
											sum = info[j][i+2]>0 ? sum+1 : sum;
										}
										
						            if( info[j][i] == 0 )
									    {
										    temp[temp_y] = j*10 + i - 1;//缺的牌
											temp_y++;
										}
								}
							if( sum > num[0] )
							    {
								    num[0] = sum;
									for( int j=15; j<=28; j++ )
									    {
										    num[j] = temp[j];
										}
								}
							sum = 0;
						}
					num[0] = num[0] + CONST_CUSTOMIZE.checkOnece_9_PLUS;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(Fan[40]+"符合:"+num[0]);
					break;
				}
				
				case SanShaiSanJieGao://41.三色三高，o缺U牌，返回0-9
				{
				    if( chiPeng > 0 )
					    {
						    int chi = 0;
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] != source[i*3+2] )//有吃
								    {
									    chi++;
									}
									else//有碰，把Y料塞回P表
								    {
										int a = source[i*3]/10;
										int b = source[i*3]%10+1;
										info[a][b] = info[a][b] + 3;//也算3
									}
						    }
							if( chi >= 2 )//2M吃，三色三高o法成立
							{
							    break;
							}
						}
						
					int[][] idx = {//配合下方圈，可得知符合
					                {0,1,2,},//f筒l
					                {0,2,1,},//fl筒
					                {1,0,2,},//筒fl
					                {1,2,0,},//筒lf
					                {2,0,1,},//lf筒
					                {2,1,0,},//l筒f
					              };
					int sum = 0;
				    for(int i=0; i<6; i++)//idx 6M
					    {
						    int[] k = idx[i];
						    for(int j=1; j<=7; j++)//刻M 123.234.345....789
							{
							    int a = info[k[0]][j]   > 1 ? info[k[0]][j]   : 0;//不
							    int b = info[k[1]][j+1] > 1 ? info[k[1]][j+1] : 0;
							    int c = info[k[2]][j+2] > 1 ? info[k[2]][j+2] : 0;
							    sum = a + b + c;//  idx[0]	的序：f筒l => 1f+2筒+3l
								if( sum > num[0] )
								    {
									    num[0] = sum;
									}
								sum = 0;
							}
						}
					num[0] = num[0] + CONST_CUSTOMIZE.checkOnece_9_PLUS;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(Fan[41]+"符合:"+num[0]);
					break;
				}
				
				//case 42 楹牌後都]番
				//case 43-46 楹牌後胡的牌B判定，妙手回春、海底圃隆上_花、和
				
                case PengPengHe://47.碰碰和
				{
					if( IsHu )
					    {
						    for( int ph=0; ph<=PaiAnalysis.hu.length-5; ph++ )
							    {
								    if( ph%3==0 && PaiAnalysis.hu[ph]!=PaiAnalysis.hu[ph+2])//胡牌列中有子==>>不是碰碰胡
									    {
										    num[0]=0;
											return num;
										}
									if( ph==9 )//绦兄链耍表示0.3.6.9的M合均o子，若有子，於上方已跳_
									    {
										    num[0]=14;
											return num;
										}
								}
						}
					int peng = 0;//碰的盗浚碰最多只有4次，避免似<七>牌型造成`判
					if( chiPeng > 0 )//有吃碰 => 算明牌的碰牌
					    {
						    int cp = chiPeng / 3;//吃碰M担此至少1
						    for( int i=0; i<cp; i++)
							    {
								    if( source[i*3]==source[i*3+2] )//吃碰M的^等於尾 => 碰2.2.2、明2.-10.2、暗2.-11.2
									    {
										    peng++;
											num[0] = num[0] + 3;
										}
								}
								
							if( cp != peng )//吃碰盗坎坏褥杜 => 有吃 => 不成立
							    {
								    num[0] = 0;
								    break;
								}
						}
						
					//num[0] = num[0] + chiPeng;//绦兄链耍表示指之前都是碰
						
					for( int i=0; i<4; i++ )//算手牌f筒l字的刻
					    for( int j=1; j<info[i].length; j++ )//各序盗
					        {
							    if( info[i][j] > 2 && peng <= 4 )//同拥氖峙朴3或4，作3(因4要暗掉才算1刻)。碰最多只有四次，超^不，避免似<七>牌型造成`判。
								    {
									    num[0] = num[0] + 3;
										peng++;
									}
								    else if( info[i][j] == 2 && peng < 4 )//同拥氖峙朴2
								    {
									    num[0] = num[0] + 2;
										peng++;
										num[y] = i*10 + (j-1);//缺一，入缺牌
									    y++;
									}
								    else if( info[i][j] > 1 && peng >= 4 )//同拥氖峙朴2，第五碰(含2缺1的牌)，符合挡挥，只缺牌(可碰)
								    {
									    if( peng == 4 )//4碰(含2缺1的牌)已M，作
										    {
											    num[0] = num[0] + 2;
										        peng++;//
											}
									    
										    num[y] = i*10 + (j-1);//缺一，入缺牌
									        y++;
									}
									else if( info[i][j] == 1 )//一的算U牌
									{
									    num[x] = i*10 + (j-1);
									    x++;
									}
						    }
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(Fan[47]+"符合:"+num[0]);
			        break;
				}
				
				case HunYiShai://48.混一色
				{
					int[] qing = { 0, 0, 0, 0 };//f筒l字的盗
					if( chiPeng > 0 )
					    {
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3]==source[i*3+2] && source[i*3]>=30 )//有碰字
								    {
									   qing[3] = qing[3] + 3;
									}
						    }
						}
					for( int i=1; i<=7; i++ )//手牌未吃碰的字，至少2才算
					    {
						    if( info[3][i]>1 ) qing[3] = qing[3] + info[3][i];
						}
				    for( int i=0; i<source.length; i++ )
					    {
						    if( source[i] == -10 || source[i] == -11 )//
							    {
								    source[i] = source[i+1];//牌中g的牌DQ苏I
								}
							int cate = source[i]/10;
						    if( cate <3 ) qing[cate]++;
						}
					
					int max = qing[0];
					if( qing[0] < qing[1] ) max = qing[1];
					if( max < qing[2] ) max = qing[2];
					
					num[0] = max + qing[3];
					if( qing[3]==0 || ( qing[0]==0&&qing[1]==0&&qing[2]==0 ) ) num[0] = 0;//]字或全字不是混一色
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("混一色符合:"+num[0]);
					break;
				}
				
				case SanShaiSanBuGao://49.三色三步高，返回0-9，有缺牌
				{
				    int[][] shun = new int[3][7];//f筒l字7N的盗
				    if( chiPeng > 0 )
					    {
						    int peng = 0;
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] == source[i*3+2] )//有碰
								    {
									    peng++;
									}
									else//有吃，吃的^
								    {
										int head = source[i*3];
										if( source[i*3+1] < head ) head = source[i*3+1];
										if( source[i*3+2] < head ) head = source[i*3+2];
										shun[head/10][head%10]++;
									}
						    }
							if( peng >= 2 )//2M碰，三色三步高o法成立
							{
							    break;
							}
						}
						
					int[][] idx = {//配合下方圈，可得知符合
					                {0,1,2,},//f筒l
					                {0,2,1,},//fl筒
					                {1,0,2,},//筒fl
					                {1,2,0,},//筒lf
					                {2,0,1,},//lf筒
					                {2,1,0,},//l筒f
					              };
								  
					int sum = 0;
				    for(int i=0; i<6; i++)//idx 6M，此回圈z查idx花色序M合
					    {
						    int[] k = idx[i];
						    for(int j=1; j<=5; j++)//的^分e 123.234.345.456.567
							{
							    int[] temp = {
                      						   0,
		                                      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
					                          -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
											  };
								int temp_x = 1;
								int temp_y = 15;
								
							    for( int s=0; s<3; s++ )
								    {
									    for( int t=0; t<3; t++ )//  idx[0]	的序：f筒l => 123f+234筒+345l
										    {
											    if( shun[k[s]][j+s-1] > 0 )//此已有吃了
												    {
													    sum = sum + 3;
														break;//此M已吃，z查下一M
													}
											    int w = ( info[k[s]][0+j+s+t] > 0 ) ? 1 : 0;
												sum = sum + w;
												if( w==0 )
												    {
													    temp[temp_y] = s*10 + j + s + t -1;//入缺牌
														temp_y++;
													}
											}
									}
								if( sum > num[0] )//EX：j=1，z查完idx[i]花色的123,234,345
								    {
									    num = temp;
									    num[0] = sum;
									}
								sum = 0;
							}
							
							/*for(int j=1; j<=3; j++ )//^ 135.246.357
							{
							    int[] temp = {
                      						   0,
		                                      -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
					                          -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
											  };
								int temp_x = 1;
								int temp_y = 15;
								
							    for( int s=0; s<3; s++ )
								    {
									    for( int t=0; t<3; t++ )//  idx[0]	的序：f筒l => 123f+345筒+567l
										    {
											    if( shun[k[s]][j+s*2-1] > 0 )//此已有吃了
												    {
													    sum = sum + 3;
														break;
													}
											    int w = ( info[k[s]][0+j+s*2+t] > 0 ) ? 1 : 0;
												sum = sum + w;
												if( w==0 )
												    {
													    temp[temp_y] = s*10 + j + s + t -1;//入缺牌
														temp_y++;
													}
											}
									}
								if( sum > num[0] )
								    {
									    num = temp;
									    num[0] = sum;
									}
								sum = 0;
							}*/
						}
					num[0] = num[0] + CONST_CUSTOMIZE.checkOnece_9_PLUS;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println(Fan[49]+"符合:"+num[0]);
					break;
				}
				
				case WuMenQi://50.五TR：三花色 + L + 箭。成立1，不成立0，o缺U牌。只要同L*2 + 同箭 *2 可避免特殊M合重}EX：七星不靠、13么
				{
					boolean wang = false, tong = false, tiau = false, feng = false, jian = false;
					if( chiPeng > 0 )
					for( int i=0; i<chiPeng/3; i++ )
					    {
						    if( source[i*3]/10==0 )  wang = true;
							else if( source[i*3]/10==1 )  tong = true;
							else if( source[i*3]/10==2 )  tiau = true;
							else if( source[i*3]/10==3 )
							    {
								    if( source[i*3]%10 <= 3 ) feng = true;
									else if( source[i*3]%10 > 3 && source[i*3]%10 <= 6 ) jian = true;
								}
						}
					for( int i=0; i<3; i++ )
					    {
						    if( info[i][0] > 0 )
							    {
								    if( i==0 ) wang = true;
									else if( i==1 ) tong = true;
									else if( i==2 ) tiau= true;
								}
						}
					
					if( wang && tong && tiau )//f筒l都有
					    {
						    for( int i=1; i<=7; i++ )
							    {
								    if( i <= 4 && info[3][i] > 1 )//L有1以上
									    {
										    feng = true;
										}
										else if( i > 4 && info[3][i] > 1 )//箭有1以上
										{
										   jian = true;
										}
								}
							if( feng && jian )
							    {
								    num[0] = 1;
								}
						}
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("五TR："+IsExist(num[0]) );
			        break;
				}
				
                case QuanQiuRen://51.全求人：不可暗
				{
				    boolean fail = false;
				    if( chiPeng > 0 )
				        for( int i=0; i<chiPeng; i++ )
					        {
						        if( source[i] == -11 )//暗：中g牌的
								    {
									    fail = true;
									    num[0] = 0;
								        break;
									}
						    }
							
					if( fail ) break;
				    num[0] = chiPeng + 2;//chiPeng=12=吃碰4M(12) + 1 ，chiPeng=9=吃碰3M(9) + 1 ...
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_ONECE ) System.out.println("全求人符合"+num[0]);
			        break;
				}
				
				case ShuangAnGang://52.p暗：前置66.暗，成立1，不成立0
				{
				    if( chiPeng > 0 )
				    for( int i=0; i<chiPeng; i++ )
					    {
						    if( source[i]==-11 )
							    {
								    num[0]++;
								}
						}
					if( num[0] > 1 ) num[0] = 1;
					    else num[0] = 0;
					break;
				}
				
				case ShuangJianKe://53.p箭刻：前置58.箭刻，成立1，不成立0
				{
					int sjk = 0;
					for( int i=0; i<hu.length/3; i++ )
					    {
						    if( hu[i*3]==hu[i*3+2] && hu[i*3]>=34 && hu[i*3]<=36 ) sjk++;
						}
					if( sjk >= 2 ) num[0] = 1;
					break;
				}
				
				case ShuangMingGang://56.p明：成立1，不成立0
				{
				    if( chiPeng > 0 )
				    for( int i=0; i<chiPeng; i++ )
					    {
						    if( source[i]==-10 )
							    {
								    num[0]++;
								}
						}
					if( num[0] > 1 ) num[0] = 1;
					    else num[0] = 0;
					break;
				}
				
				//case 57 楹牌後胡的牌B判定
				
				case JianKe://58.箭刻：成立1，不成立0
				{
				    for( int i=0; i<source.length-2; i++ )
					    {
						    if( source[i] == source[i+2] && source[i]>=34 )
							    {
								    num[0] = 1;
									break;
								}
							    
						}
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("箭刻："+IsExist(num[0]) );
					break;
				}
				
				case QuanFengKe://59.圈L刻：成立1，不成立0
				{
				    for( int i=0; i<source.length-2; i++ )
					    {
						    if( source[i] == source[i+2] && source[i]>=30 && source[i]%10==quanFeng )
							    {
								    num[0] = 1;
									break;
								}
							    
						}
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("圈L刻："+IsExist(num[0]) );
				    break;
				}
				
				case MenFengKe://60.TL刻：成立1，不成立0，f家|L，依序槟衔鞅憋L
				{
				    for( int i=0; i<source.length-2; i++ )
					    {
						    if( source[i] == source[i+2] && source[i]>=30 && source[i]%10==(player+4-LGame.banker)%4 )
							    {
								    num[0] = 1;
									break;
								}
							    
						}
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("TL刻："+IsExist(num[0]) );
				    break;
				}
				
				case MenQianQing://61.T前清(非自摸)
				{
				    num[0] = 1;
				    if( chiPeng > 0 )//chiPeng大於0s可成立，只有都是暗才行，任1不是暗to法成立
					    {
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3+1] != -11 )//有吃碰，但中g牌的不是暗 = > 不成立
								    {
									    num[0] = 0;
								        break;
									}
						    }
						}
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("T前清OR不求人："+IsExist(num[0]) );
					break;
				}
				
				case SiQuiYi://63.四w一，可重}算，四非，成立1，不成立0，o缺U牌
				{
				    int[] sqy = new int[14];
					for( int i=0; i<14; i++ ) sqy[i] = source[i];
					liPai( sqy, 0, 13);//擞-10-11被排到最前面
					for( int i=0; i<sqy.length-3; i++ )
					    {
						    if( sqy[i] >= 0 && sqy[i] == sqy[i+3] )//不是，排序後隔2是相同的牌 = > 成立 ，牌是3.-10.3 或 3.-11.3，不是3.3.3.3
							    {
								    num[0] = num[0]+1;
								}
						}
					if( num[0] >1 ) num[0] = 1;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("四w一："+IsExist(num[0]) );
					break;
				}
				
				case ShuangTongKe://64.p同刻
				{
				    if( chiPeng > 0 )
					    {
						    int chi = 0;
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] == source[i*3+2] )//有碰，把Y料塞回P表
								    {
										int a = source[i*3]/10;
										int b = source[i*3]%10+1;
										info[a][b] = info[a][b] + 3;//也算3
									}
						    }
						}
						
					for( int i=1; i<=9; i++ )
					    {
						    int tmp = 0;
						    for( int j=0; j<=2; j++ )
							    {
								    if( info[j][i] >=3 )  tmp++;
								}
							if( tmp>=2 ) num[0]++;
						}
					if( num[0] >1 ) num[0] = 1;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("p同刻："+IsExist(num[0]) );
					break;
				}
				
				case ShuangAnKe://65.p暗刻：成立1，不成立0
				{
				    int sak = 0;
					//int sak2 = 0;
					int sak3 = 0;
				    if( chiPeng > 0 )//z查暗
					    {
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3+1] == -11 )//是暗
								    {
									    sak++;
									}
						    }
						}
					
					/*for( int i=chiPeng/3; i<hu.length/3; i++ )
					    {
						    if( hu[i*3]==hu[i*3+2] ) sak2++;
						}*/
					for( int i=0; i<=3; i++ )//四花色
					    {
						    for( int j=1; j<=9; j++ )
							    if( info[i][j]>=3 )//111222333=>123123123，所以要z查手牌
							        {
								        sak3++;
								    }
						}
					//if( sak2 > sak3 ) sak = sak + sak2;
					    //else 
						sak = sak + sak3;
					if( sak >= 2 ) num[0] = 1;
						else num[0] = 0;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("p暗刻："+IsExist(num[0]) );
					break;
				}
				
				case AnGang://66.暗，成立1，不成立0。
				{
				    if( chiPeng > 0 )
				    for( int i=0; i<chiPeng; i++ )
					    {
						    if( source[i]==-11 )
							    {
								    num[0]++;
									break;
								}
						}
					if( num[0] > 0 ) num[0] = 1;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("暗："+IsExist(num[0]) );
					break;
				}
				
				case DuanYao://67.嗝矗]有1.9.字，成立1，不成立0
				{
				    num[0] = 1;
					for( int i=0; i<source.length; i++ )
					    {
						    if( source[i] <= 28 && ( source[i]%10==0 || source[i]%10==8 ) )//1 OR 9
							    {
								    num[0] = 0;
									break;//不成立，停止判
								}
							    else if( source[i] > 28 )//是字牌
							    {
								    num[0] = 0;
									break;//不成立，停止判
								}
						}
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("嗝矗"+IsExist(num[0]) );
					break;
				}
				
				case YiBanGao://68.一般高：同花之同
				{
					int[][] shun = new int[3][7];//f筒l字7N的盗
					    
				    if( chiPeng > 0 )
					    {
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] != source[i*3+2] )//有吃，z查吃M之^
								    {
										int head = source[i*3];
										if( source[i*3+1] < head ) head = source[i*3+1];
										if( source[i*3+2] < head ) head = source[i*3+2];
											
										shun[head/10][head%10]++;
									}
						    }
						}
						
					for( int i=0; i<=2; i++ )//依序z查f筒l的所有
					    {
						    for( int j=1; j<=7; j++ )
							    {
								    if( info[i][j] > 0 && info[i][j+1] > 0 && info[i][j+2] > 0 )
									    {
										    shun[i][j-1]++;
											if( info[i][j] > 1 && info[i][j+1] > 1 && info[i][j+2] > 1 )//EX：334455，333444555就是1色3同了，不用算一般高
											    {
												    shun[i][j-1]++;
												}
										}
								}
						}
						
					for( int i=0; i<=2; i++ )//z查所有盗渴欠裼2以上
					    for( int j=0; j<=6; j++ )
						    {
							    if( shun[i][j] > 1 )  num[0]++;
							}
					if( num[0]>1 ) num[0] = 1;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("一般高："+IsExist(num[0]) );
					break;
				}
				
				case XiXiangFeng://69.喜相逢：花色之同，最多2
				{
				    int[][] shun = new int[3][7];//f筒l字7N的盗
					if( chiPeng > 0 )
					    {
						    int peng = 0;
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] != source[i*3+2] )//有吃，吃的^
								    {
										int head = source[i*3];
										if( source[i*3+1] < head ) head = source[i*3+1];
										if( source[i*3+2] < head ) head = source[i*3+2];
										shun[head/10][head%10]++;
									}
						    }
						}
						
					for( int i=0; i<=2; i++ )//f筒l
					    {
						    for( int j=1; j<=7; j++ )//7N^
							    {
								    if( info[i][j]>0 && info[i][j+1]>0 && info[i][j+2]>0 )
									    {
										    shun[i][j-1]++;//o手牌有的
										}
								}
						}
					
					for( int i=0; i<=6; i++ )
					    {
						    int tmp = 0;
						    for( int j=0; j<=2; j++ )
							    {
								    if( shun[j][i] > 0 ) tmp++;
								}
							if( tmp==2 ) num[0]++;//只有2花色有，3花色有就算三同了
						}
					if( num[0]>1 ) num[0] = 1;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("喜相逢："+IsExist(num[0]) );
					break;
				}
				
				case LianLu://70.B六：1花色最多1B六
				{
				    int[][] shun = new int[3][7];//f筒l7N的盗
					if( chiPeng > 0 )
					    {
						    int peng = 0;
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] != source[i*3+2] )//有吃，吃的^
								    {
										int head = source[i*3];
										if( source[i*3+1] < head ) head = source[i*3+1];
										if( source[i*3+2] < head ) head = source[i*3+2];
										shun[head/10][head%10]++;
									}
						    }
						}
						
					for( int i=0; i<=2; i++ )//f筒l
					    {
						    for( int j=1; j<=7; j++ )//7N^
							    {
								    if( info[i][j]>0 && info[i][j+1]>0 && info[i][j+2]>0 )
									    {
										    shun[i][j-1]++;//o手牌有的
										}
								}
						}
					
					for( int i=0; i<=2; i++ )//f筒l
					    {
						    for( int j=0; j<4; j++ )//1+4.2+5.3+6.4+7
							    {
								    if( shun[i][j]>0 && shun[i][j+3]>0)//EX: 234+567
									    {
										    num[0]++;
											break;//1花色最多1B六
										}
								}
						}
					if( num[0]>1 ) num[0] = 1;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("B六："+IsExist(num[0]) );
					break;
				}
				
				case LaoShaoFu://71.老少副：同花色123+789，成立1，不成立0。o缺U牌
				{
				    int[][] set = {
					                 {0,0},//f筒l的123+789
					                 {0,0},
					                 {0,0},
								  };
				    if( chiPeng > 0 )
					    {
						    for( int i=0; i<( chiPeng / 3 ); i++ )
					        {
						        if( source[i*3] != source[i*3+2] )//有吃，z查吃M是否123或789
								    {
										int head = source[i*3];
										if( source[i*3+1] < head ) head = source[i*3+1];
										if( source[i*3+2] < head ) head = source[i*3+2];
											
										if( head%10 == 0 )//123
										    {
											    set[source[i*3]/10][0]++;
											}
											else if( head%10 == 6 )//789
											{
											    set[source[i*3]/10][1]++;
											}
									}
						    }
						}
						
					for( int i=0; i<=2; i++ )//依序z查f筒l的123+789
					    {
						    for( int j=0; j<=3; j++ )//同花色最多同r有4123
							    {
								    if( info[i][1]-j>0 && info[i][2]-j>0 && info[i][3]-j>0 )//各p j  仍不是的，表示可以B加 j+1 次
							            {
								            set[i][0]++;
								        }
										else
										{
										    break;//有樨的：已o123
										}
								}
						    for( int j=0; j<=3; j++ )//同花色最多同r有4789
							    {
								    if( info[i][7]-j>0 && info[i][8]-j>0 && info[i][9]-j>0 )//各p j  仍不是的，表示可以B加 j+1 次
							            {
								            set[i][1]++;
								        }
										else
										{
										    break;//有樨的：已o789
										}
								}
						}
						
					for( int i=0; i<=2; i++ )
					    {
						    if( set[i][0] > set[i][1] )//取各花色123.789中^少者槔仙俑贝嬖
							    {
								    num[0] = num[0] + set[i][1];
								}
								else
								{
								    num[0] = num[0] + set[i][0];
								}
						}
						
					if( num[0] > 0 ) num[0] = 1;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("老少副："+IsExist(num[0]) );
					break;
				}
				
				case YaoJiuKe://72.么九刻：1.9刻，非TL圈L的L刻
				{
				    for( int i=0; i<source.length; i++ )
					    {
						    if( i+2 < source.length && source[i] == source[i+2] )
							    {
									if( source[i] < 30 && ( source[i]%10==0 || source[i]%10==8 ) )//三花色的1.9刻
									    {
										    num[0]++;
										}
										else if( source[i] >= 30 && source[i] <= 33 && source[i]%10!=quanFeng && source[i]%10!=(player+4-LGame.banker)%4 )//L刻非圈LTL
										{
										    num[0]++;
										}
								}
						}
					
					if( num[0] > 0 ) num[0] = 1;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("么九刻："+IsExist(num[0]) );
					break;
				}
				
				case MingGang://73.明，成立1，不成立0。
				{
				    if( chiPeng > 0 )
				    for( int i=0; i<chiPeng/3; i++ )
					    {
						    if( source[i*3+1]==-10 )
							    {
								    num[0]++;
									break;
								}
						}
					if( num[0] > 0 ) num[0] = 1;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("明："+IsExist(num[0]) );
					break;
				}
				
				case QueYiMen://74.缺一T：f筒l缺1N，成立1，不成立0，o缺U牌
				{
				    num[0] = 1;
					boolean wang = false;
					boolean tong = false;
					boolean tiau = false;
					for( int i=0; i<source.length; i++ )
					    {
						    int qym = source[i]/10;
						    if( qym == 0 ) wang = true;
							else if( qym==1 ) tong = true;
							else if( qym==2 ) tiau = true;
						}
					
					int rst = 0;
					rst = wang ? rst + 1 : rst;
					rst = tong ? rst + 1 : rst;
					rst = tiau ? rst + 1 : rst;
					
					if( rst != 2 )  num[0] = 0;
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("缺一T："+IsExist(num[0]) );
					break;
				}
				
				case WuZi://75.o字，成立1，不成立0
				{
				    num[0] = 1;
					for( int i=0; i<source.length; i++ )
					    {
						    if( source[i] > 28 )//是字牌
							    {
								    num[0] = 0;
									break;//不成立，停止判
								}
						}
					if( CONST_CUSTOMIZE.TRACE_CODE && CONST_CUSTOMIZE.TRACE_CHECK_OFTEN && num[0]!=0 ) System.out.println("o字："+IsExist(num[0]) );
					break;
				}
				
				//case 76,77,78,79 楹牌後胡的牌B判定
				//case 80 花牌，胡牌後才算
				case -1:
				case -2:
				    num[0]=0;
				    break;
		        default:
				    System.out.println("PaiAnalysis.checkType WRONG!! target="+target);
					break;
			}
			}catch(Exception e)
			    { 
				    System.out.println("chiPeng="+chiPeng+"_target="+target+"_"+e); 
					System.out.println("player="+player+"_IsHu="+IsHu);
					for(int q=0;q<14;q++)
					    System.out.print("_"+source_x[q]);
						System.out.println("_+_");
				}
		return num;
	}
	
	
	/**回髟牌列中符合3+2的最高符合担EX：已剔除符合M合的牌(被剔除的牌耸-1)，剩N的在此z查最高符合担回髦2-5
 	*@param left 要z查的牌列
 	*@return int[] index 0榉合担index 1-14 U牌代a
 	*/
	/*private static int checkLeftPai( int[] left )
	{
	    //符合担F，先找是否有1
		//若有1<F+2>，t再找刻或<F+3>、刻缺1或缺1<F+2>、刻缺2或缺2<F+1>
		//若o1<F+1>，t再找刻或<F+3>、刻缺1或缺1<F+2>、刻缺2或缺2<F+1>
		boolean yiDui = false;//是否lF一
		int fu = 0;
		int fu_tmp = 0;//捍嬲业降淖畲蠓合
		liPai(left, 0, left.length-1);//列L度若10，index最大9
		
		for( int i=0; i<=left.length-2; i++ )//找1Γ列L度若10，index最大9，最多找到index 8
		    {
			    if( left[i] != -1 && left[i] == left[i+1] )//有1Γ有一Φ乃有r，最多5，最少有3：1 + 1。
				    {
					    fu_tmp = fu_tmp + 2;
					    if( i+2 <= left.length-1 && left[i] == left[i+2] )//列L度若10，index最大9，i+2 不能大於9，i+2 存在且有刻
						    {
							    fu_tmp = fu_tmp + 1;//以槭ΓY果是刻，+1
								        int cate = left[i] / 10;
										if( cate < 3 )//不是字牌，有刻，z查刻的第三是否轫^、中或尾
										    {
											    boolean b1=false, b2=false, b3=false, b4=false;
											    if( i-1 >= 0               && left[i-1]   == left[i]-1 ) b1 = true;//EX：4f前面有3f => 2==3-1
												if( i-2 >= 0               && left[i-2]   == left[i]-2 ) b2 = true;//EX：4f前面有2f
											    if( i+2+1 <= left.length-1 && left[i+2+1] == left[i]+1 ) b3 = true;//EX：4f後面有5f
												if( i+2+2 <= left.length-1 && left[i+2+2] == left[i]+2 ) b4 = true;//EX：4f後面有6f
												if( (b1 && b2) || (b3 && b4) || (b1 && b3) )//尾 或 ^ 或 中
												    {
													    fu_tmp = fu_tmp + 2;//一 + 一
														//fu = fu_tmp;
														break;
													}
													else if( b1 || b2 || b3 || b4 )//p^或中洞
													{
													    fu_tmp = fu_tmp + 1;
													}
											}
								if( (i+2)+2 <= (left.length-1) )//列L度若10，index最大9，已有刻，i+2後面若有2以上才需z查是否有
								    {
									    for( int k=(i+2)+1; k<=left.length-2; k++ )//找1Γ列L度若10，index最大9，最多找到index 8，起始位置找到的刻後面的牌
										    {
											    if( left[i] != -1 && left[k] == left[k+1] )//有1
												    {
													    fu_tmp = fu_tmp + 2;//一刻 + 一
														yiDui = true;
														break;
													}
											}
										if( yiDui ) 
										    {
											    fu = fu_tmp;
												break;
											}
									}
								
							}
							else//有1Γ不成刻，ψ颖旧硪o成的可能：_始找以外的或刻，分_找，求最大值
							{
							    //int temp = 2;//捍嬲业降淖畲蠓合(1)
								
							    for( int j=0; j<=left.length-2; j++ )//列L度若10，index最大9，最多找到index 8
								    {int temp = 2;//捍嬲业降淖畲蠓合(1)
									    //找刻子
									    if( left[j] != -1 && left[j] != left[i] && left[j] == left[j+1] )//另1Mψ
										    {
											    temp = temp + 2;
											    if( j+2 <= left.length-1 && left[j] == left[j+2] )//lF刻子
												    {
													    temp = temp + 1;//以槭ΓY果是刻，+1，3+2 找完>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Y束
														break;
													}
													else//不是刻子，只是一
													{
													    break;
													}
											}
										//找子，先排除字牌及已找到不成刻的1
										int cate = left[j] / 10;
										if( cate < 3 && left[j] != left[i] )//非字牌、非上面的一
										    {
											    boolean b1=false, b2=false, b3=false, b4=false;
											    if( j-1 >= 0               && left[j-1]   == left[j]-1 ) b1 = true;//EX：4f前面有3f => 2==3-1
												if( j-2 >= 0               && left[j-2]   == left[j]-2 ) b2 = true;//EX：4f前面有2f
											    if( j+2+1 <= left.length-1 && left[j+2+1] == left[j]+1 ) b3 = true;//EX：4f後面有5f
												if( j+2+2 <= left.length-1 && left[j+2+2] == left[j]+2 ) b4 = true;//EX：4f後面有6f
												if( (b1 && b2) || (b3 && b4) || (b1 && b3) )//尾 或 ^ 或 中
												    {
													    temp = temp + 3;//一 + 一
														yiDui = true;//5了=.=
														break;
													}
													else if( b1 || b2 || b3 || b4 )//p^或中洞
													{
													    temp = temp + 2;
													}
											}
										if( temp > fu )
										    {
											    fu = temp;//取^大的值
												temp = 2;//回到M淼闹
											}
									}
								if( yiDui ) break;//5了=.=
							}
					}
					
				if( fu_tmp > fu )
				    {
					    fu = fu_tmp;
					}
				fu_tmp = 0;
			}
			
			//若上面已有5，下面不用算了，因橛算Y果最多就是5
			//下面因]有ψ铀以最多只有4< 1 + 1眼 >，所以fu == 4 下面也不用算了
			if( fu < 4 )//]有ψ樱，找子
			    {
				    int temp2 = 0;
				    for( int i=0; i<=left.length-1; i++ )//找、缺1，列L度若10，index最大9，最多找到index 9
					    {
							int cate = left[i] / 10;
							if( cate < 3 && left[i] != -1 )//非字牌、空牌
							    {
									boolean b1=false, b2=false, b3=false, b4=false;
									if( i-1 >= 0               && left[i-1]   == left[i]-1 ) b1 = true;//EX：4f前面有3f => 2==3-1
									if( i-2 >= 0               && left[i-2]   == left[i]-2 ) b2 = true;//EX：4f前面有2f
									if( i+2+1 <= left.length-1 && left[i+2+1] == left[i]+1 ) b3 = true;//EX：4f後面有5f
									if( i+2+2 <= left.length-1 && left[i+2+2] == left[i]+2 ) b4 = true;//EX：4f後面有6f
									if( (b1 && b2) || (b3 && b4) || (b1 && b3) )//尾 或 ^ 或 中
										 {
											temp2 = 4;//1 + 1眼
											break;//>>>>>>>>>已最大，Y束!!!!
										}
										else if( b1 || b2 || b3 || b4 )// p^或中洞
											{
											    temp2 = 3;// 缺1 + 1眼
											}
										else if( !b1 && !b2 && !b3 && !b4 )
										    {
											    temp2 = 2;// 缺2 + 1眼
											}
								}
							
							if( temp2 > fu )
							    {
								    fu = temp2;//取^大的值
									temp2 = 0;
								}
						}
				}
			
		if( fu > 5 ) System.out.println("checkLeftPai 算e`!!!!   fu="+fu+"_"+left[0]+"_"+left[1]+"_"+left[2]+"_"+left[3]+"_"+left[4]+"_"+left[5]+
		"_"+left[6]+"_"+left[7]+"_"+left[8]+"_"+left[9]+"_"+left[10]+"_"+left[11]+"_"+left[12]+"__"+left[13] );
		
		return fu;
		
	}*/

	/**理牌，如果前面的牌比後面的大就φ{
 	*@param pai[] 要理的牌列
 	*@param begin 起始的位置(包含)
 	*@param end Y束的位置(包含)
 	*/
    public static int[] liPai(int pai[], int begin, int end)
	{ 
      int tmp;
      for (int i = begin; i < end; i++) 
	  {
        for (int j = i+1; j < end+1; j++) 
		{
          if (pai[i]> pai[j]) 
		  {
            tmp = pai[i];
            pai[i] = pai[j];
            pai[j] = tmp;
          }
        }
      }
     return pai;
    }
	
	public static int pai_firstPlace( int[] pai, int val, int begin, int end )//在牌中g搜索一牌的第1次出F的位置
	{
        for (int i = begin; i <= end; i++)
          if (pai[i] == val)
            return i;
        return -1;
    }
	
	private static String IsExist(int num)
	{
	    String AS = "成立";
		String AD = "不成立";
		String AF = "@是什NB?";
		if( num==0 ) return AD;
		else if( num==1 ) return AS;
		else return AF;
	}
	
	/**z查吃碰指後方的牌是否符合3332的M合，所有-3去掉tm用16MJ，理完的牌，⒀墼谧钺2 ，吃碰指前的不
 	*@param pai[] 要理的牌列
 	*@param chipeng 起始的位置(包含)
 	*/
    public static boolean IsHuPai(int target[], int chipeng)
	{ 
	    for( int i=0; i<chipeng; i++ )
		    {
			    hu[i] = target[i];
			} 
		System.arraycopy(target, 0, pai, 0, target.length);
		boolean hupai = jibenPutong2( chipeng, false );
		
		return hupai;
    }
	
	private static boolean jibenPutong2(int i, boolean ydui)
    {
        //i：_始位置；ydui：是否有ψ
	    liPai(pai, i, 13);//理牌
        if (!ydui && (pai[i] == pai[i + 1]))  //是否有ψ
		    {
                if ( (i + 2 == 17-3) || (jibenPutong2(i + 2, true))) 
				    {
                        hu[15-3] = pai[i];
                        hu[16-3] = pai[i];
                        return true;
                    }
            }
      
        if (i < 15-3) 
            {
                if ( (pai[i] == pai[i + 1]) && (pai[i] == pai[i + 2])) //有三一
                    { 
                        if (i == 14-3)
                            {  
                                hu[12-3] = hu[13-3] = hu[14-3] = pai[i];
                                return true;
                            }
                            else if (jibenPutong2(i + 3, ydui))
                                {
                                    if(ydui)
                                        {
                                            hu[i-2] = hu[i-1] = hu[i] = pai[i];
                                        }
                                        else
                                        {
                                            hu[i] = hu[i+1] = hu[i+2] = pai[i];
                                        }
                                    return true;
                                }
                    }
            }

        if (pai[i] < 30) 
		    {
                int find1 = pai_firstPlace( pai, pai[i] + 1, i + 1, 16-3 );  //在牌中g搜索一牌的第1次出F的位置，主要是判嗍遣皇琼子
                int find2 = pai_firstPlace( pai, pai[i] + 2, i + 1, 16-3 );
                if ( (find1 != -1) && (find2 != -1)) //不是-1表示有找到
				    {                 
                        if (i ==14-3)
						    {
                                hu[12-3] = pai[i];
                                hu[13-3] = pai[i]+1;
                                hu[14-3] = pai[i]+2;
                                return true;
                            }
							else
							{
                                pai[find1] = pai[i + 1];
                                pai[i + 1] = pai[i] + 1;
                                pai[find2] = pai[i + 2];
                                pai[i + 2] = pai[i] + 2;
                                if(jibenPutong2(i + 3, ydui))
								    {
                                        if(ydui)
										    {
                                                hu[i-2] = pai[i];
                                                hu[i-1] = pai[i]+1;
                                                hu[i] = pai[i]+2;
                                            }
											else
											{
                                                hu[i] = pai[i];
                                                hu[i+1] = pai[i]+1;
                                                hu[i+2] = pai[i]+2;
                                            }
                                        return true;
                                    }
                            }
                    }
            }
        return false;
    }
	
}




/////////////////////////////////////////////////////////////////////////////
//
//    Copyright (C) 2009 Joymaster Corporation. All Rights Reserved.
//
//////////////////////////////////////////////////////////////////////////////
